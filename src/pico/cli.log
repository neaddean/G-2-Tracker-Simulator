KCPSM6 Assembler log file for program 'Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cli.psm'.
Generated by KCPSM6 version v2.46
Ken Chapman - Xilinx Ltd - 18th February 2013

Assembly datestamp: 21 Feb 2014
Assembly timestamp: 14:26:30

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 375 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 886
Memory locations available: 3210


Assembly listing

 Addr Code                                 Instruction

 000                                       ;;; ============================================================================
 000                                       ;;; EPP RAM test via UART UI
 000                                       ;; Dan Gastler
 000                                       ;; Boston University Electronics Design Facility
 000                                       ;; 2013-10-18 v1.0
 000                                       ;;; ============================================================================
 000                                       ;;; ============================================================================
 000                                       ;;; Register map
 000                                       ;;; ============================================================================
 000                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 000                                       ;;; | soft_reset | x  |    |
 000                                       ;;; | hard_reset | x  | x  | x  |    |    |    |    |    |    |    | x  |  x |
 000                                       ;;; | start  | x  | x  |
 000                                       ;;; | cli_loop   |
 000                                       ;;; | print_EOL  |
 000                                       ;;; ============================================================================
 000                                       ;;; Scratchpad memory map
 000                                       ;;; ============================================================================
 000                                       CONSTANT CLI_BUFFER_START, 00                    ; Start of the UART buffer
 000                                       CONSTANT CLI_BUFFER, 20                          ; Current write pointer in the CLI buffer
 000                                       CONSTANT CLI_COUNT, 23                           ; Number of valid parsed 16bit words on
 000                                       ; the command line
 000                                       CONSTANT CLI_WORD_1_POS, 24                      ; position in CLI_BUFFER where WORD1 starts
 000                                       CONSTANT CLI_WORD_2_POS, 25                      ; position in CLI_BUFFER where WORD2 starts
 000                                       CONSTANT CLI_WORD_3_POS, 26                      ; position in CLI_BUFFER where WORD3 starts
 000                                       CONSTANT CLI_WORD_4_POS, 27                      ; position in CLI_BUFFER where WORD4 starts
 000                                       CONSTANT CLI_WORD_1_SIZE, 28                     ; number of nibbles in this word
 000                                       CONSTANT CLI_WORD_2_SIZE, 29                     ; number of nibbles in this word
 000                                       CONSTANT CLI_WORD_3_SIZE, 2A                     ; number of nibbles in this word
 000                                       CONSTANT CLI_WORD_4_SIZE, 2B                     ; number of nibbles in this word
 000                                       CONSTANT CLI_WORD_1, 2C                          ; LSB of parsed word 1 (+ for MSB)
 000                                       CONSTANT CLI_WORD_2, 30                          ; LSB of parsed word 1
 000                                       CONSTANT CLI_WORD_3, 34                          ; LSB of parsed word 1
 000                                       CONSTANT CLI_WORD_4, 38                          ; LSB of parsed word 1
 000                                       CONSTANT MEM_USER_1, 40                          ; Start of User mem block 1
 000                                       CONSTANT MEM_USER_2, 80                          ; Start of User mem block 2
 000                                       CONSTANT MEM_USER_3, C0                          ; Start of User mem block 3
 000                                       CONSTANT MEM_SIZE, FF                            ; Size of our scratchpad memory
 000                                       ;;; ============================================================================
 000                                       ;;; Constants
 000                                       ;;; ============================================================================
 000                                       CONSTANT UI_VERSION, 01
 000                                       ;; input ports
 000                                       CONSTANT FIFO_data, 03
 000                                       CONSTANT FIFO_flags, 04
 000                                       ;; constant out ports
 000                                       CONSTANT UART_TX_RESET_PORT, 00
 000                                       ;; output ports
 000                                       CONSTANT INITPORT, 00001000'b
 000                                       CONSTANT ONCEPORT, 00001001'b
 000                                       CONSTANT LED_PORT, 00000010'b
 000                                       CONSTANT SPI_PORT, 00000011'b
 000                                       CONSTANT PERIOD_PORT0, 01000000'b
 000                                       CONSTANT PERIOD_PORT1, 01000001'b
 000                                       CONSTANT PERIOD_PORT2, 01000010'b
 000                                       CONSTANT PULSE_PERIOD_PORT0, 01000100'b
 000                                       CONSTANT PULSE_PERIOD_PORT1, 01000101'b
 000                                       CONSTANT PULSE_PERIOD_PORT2, 01000110'b
 000                                       CONSTANT CTRL_port, 00100000'b
 000                                       CONSTANT C5_data, 11100000'b
 000                                       CONSTANT RESET_fifo_port, 11100010'b
 000                                       ;; spi bits
 000                                       CONSTANT spi_clk, 00000001'b                     ;   spi_clk - bit0 (SPI_output_por0t)
 000                                       CONSTANT spi_cs, 00000010'b                      ;  spi_cs - bit1 (SPI_output_port)
 000                                       CONSTANT spi_mosi, 10000000'b                    ;  spi_mosi - bit7 (SPI_output_port)
 000                                       NAMEREG sC, SPI_HIGH
 000                                       NAMEREG sD, SPI_LOW
 000                                       ;;; ============================================================================
 000                                       ;;; START
 000                                       ;;; ============================================================================
 000                                start: 
 000  20091                                CALL 091[hard_reset]
 001  22325                                JUMP 325[cli_loop]
 002                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\uart.psm"["uart.psm"]
 002                                       ;;; ============================================================================
 002                                       ;;; Register map
 002                                       ;;; ============================================================================
 002                                       ;;; | name                  | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 002                                       ;;; | uart_output_wait      | x  |
 002                                       ;;; | uart_output_wait      | x  |
 002                                       ;;; | uart_input_data       | x  |
 002                                       ;;; | uart_output_data      | x  |
 002                                       ;;; | uart_input_full       | x  |
 002                                       ;;; | uart_output_full      | x  |
 002                                       ;;; | uart_input_half_full  | x  |
 002                                       ;;; | uart_output_half_full | x  |
 002                                       ;;; ============================================================================
 002                                       ;;; CONSTANTS
 002                                       ;;; ============================================================================
 002                                       ;;; UART ports
 002                                       CONSTANT UART_STATUS, 00                         ; Port with the RX/TX status bits
 002                                       CONSTANT UART_INPUT, 01                          ; 8bit reading port on microC
 002                                       CONSTANT UART_OUTPUT, 01                         ; 8bit writing port on microC
 002                                       ;;; uart status constants
 002                                       CONSTANT UART_STATUS_Tx_data_present, 00000001'b ; bit 0:  tx data present
 002                                       CONSTANT UART_STATUS_Tx_half_full, 00000010'b    ; bit 1:  tx half full (8 elements in FIFO)
 002                                       CONSTANT UART_STATUS_Tx_full, 00000100'b         ; bit 2:  tx full (16 elements in FIFO)
 002                                       CONSTANT UART_STATUS_Rx_data_present, 00001000'b ; bit 3:  rx data present
 002                                       CONSTANT UART_STATUS_Rx_half_full, 00010000'b    ; bit 4:  rx half full (8 elements in FIFO)
 002                                       CONSTANT UART_STATUS_Rx_full, 00100000'b         ; bit 5:  tx full (16 elements in FIFO)
 002                                       ;;; ============================================================================
 002                                       ;;; UART Tools
 002                                       ;;; ============================================================================
 002                                       ;;; wait for an available output space
 002                     uart_output_wait: 
 002  09000                                INPUT s0, 00[UART_STATUS]
 003  0D004                                TEST s0, 04[UART_STATUS_Tx_full]                 ; check if the tx FIFO is full
 004  31000                                RETURN Z
 005  22002                                JUMP 002[uart_output_wait]
 006                                       ;;; wait for UART input
 006                      uart_input_wait: 
 006  09000                                INPUT s0, 00[UART_STATUS]
 007  09F04                                INPUT sF, 04[FIFO_flags]
 008  2DF02                                OUTPUT sF, 02[LED_PORT]
 009  0D008                                TEST s0, 08[UART_STATUS_Rx_data_present]         ; check if the rx FIFO is full
 00A  39000                                RETURN C
 00B  22006                                JUMP 006[uart_input_wait]
 00C                                       ;;; Non-blocking tests
 00C                                       ;;; check if there is data to read, C=1 if true
 00C                      uart_input_data: 
 00C  09000                                INPUT s0, 00[UART_STATUS]
 00D  0D008                                TEST s0, 08[UART_STATUS_Rx_data_present]         ; test for input data
 00E  25000                                RETURN 
 00F                                       ;;; check if there is data in the FIFO to send, C=1 if true
 00F                     uart_output_data: 
 00F  09000                                INPUT s0, 00[UART_STATUS]
 010  0D001                                TEST s0, 01[UART_STATUS_Tx_data_present]         ; test for output data
 011  25000                                RETURN 
 012                                       ;;; check if the input buffer is full, C=1 if true
 012                      uart_input_full: 
 012  09000                                INPUT s0, 00[UART_STATUS]
 013  0D020                                TEST s0, 20[UART_STATUS_Rx_full]                 ; check if the rx FIFO is full
 014  25000                                RETURN 
 015                                       ;;; check if the output buffer is full, C=1 if true
 015                     uart_output_full: 
 015  09000                                INPUT s0, 00[UART_STATUS]
 016  0D004                                TEST s0, 04[UART_STATUS_Tx_full]                 ; check if the tx FIFO is full
 017  25000                                RETURN 
 018                                       ;;; check if the input buffer is half full, C=1 if true
 018                 uart_input_half_full: 
 018  09000                                INPUT s0, 00[UART_STATUS]
 019  0D010                                TEST s0, 10[UART_STATUS_Rx_half_full]            ; check if the rx FIFO is full
 01A  25000                                RETURN 
 01B                                       ;;; check if the output buffer is half full, C=1 if true
 01B                uart_output_half_full: 
 01B  09000                                INPUT s0, 00[UART_STATUS]
 01C  0D002                                TEST s0, 02[UART_STATUS_Tx_half_full]            ; check if the tx FIFO is full
 01D  25000                                RETURN 
 01E                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\utils.psm"["utils.psm"]
 01E                                       ;;; ============================================================================
 01E                                       ;;; Register map
 01E                                       ;;; ============================================================================
 01E                                       ;;; | name                     | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 01E                                       ;;; | util_hex_to_byte         | x  | x  | x  | x  |    |    |    |    |    |    |    |    |
 01E                                       ;;; | util_char_to_nibble      | x  |    |    |    |    |    |    |    |    |    |    |    |
 01E                                       ;;; | util_byte_to_hex         | x  | x  | x  |    |    |    |    |    |    |    |    |    |
 01E                                       ;;; | util_print_byte_to_hex   | x  | x  | x  |    |    |    |    |    |    |    |    |    |
 01E                                       ;;; | util_print_EOL           | x  | x  |    |    |    |    |    |    |    |    |    |    |
 01E                                       ;;; | util_print_prompt        | x  | x  |    |    |    |    |    |    |    |    |    |    |
 01E                                       ;;; | util_print_string        | x  | x  |    |    |    |    |    |    |    |    | x  | x  |
 01E                                       ;;;
 01E                                       ;;; ============================================================================
 01E                                       ;;; Convert two bytes of ascii to hex
 01E                                       ;; return byte in s0, C=1 for sucess, C=0 for failure
 01E                                       ;; load two ASCII characters in s2(MSB),s1(LSB)
 01E                                       ;; this uses s0-s3
 01E                                       ;;; ============================================================================
 01E                     util_hex_to_byte: 
 01E                                       ;; check and convert MSB
 01E  00020                                LOAD s0, s2                                      ; Call util_char_to_nibble to convert and check this is hex
 01F  20031                                CALL 031[util_char_to_nibble]
 020  3E02E                                JUMP NC, 02E[util_hex_to_byte_error]             ; jump to error if we failed
 021                                       ;; store result in the MSBs of s3
 021  00300                                LOAD s3, s0
 022  14306                                SL0 s3
 023  14306                                SL0 s3
 024  14306                                SL0 s3
 025  14306                                SL0 s3
 026                                       ;; check and convert LSB
 026  00010                                LOAD s0, s1
 027  20031                                CALL 031[util_char_to_nibble]
 028  3E02E                                JUMP NC, 02E[util_hex_to_byte_error]             ; jump to error if we failed
 029                                       ;; combine into s3,
 029  10300                                ADD s3, s0
 02A                                       ;; we converted sucessfully, so set C=1 and return s3 in s0
 02A  01001                                LOAD s0, 01
 02B  1400E                                SR0 s0
 02C  00030                                LOAD s0, s3
 02D  25000                                RETURN 
 02E               util_hex_to_byte_error: 
 02E  01000                                LOAD s0, 00                                      ; set s0 to zero and C=0
 02F  1400E                                SR0 s0
 030  25000                                RETURN 
 031                                       ;;; ============================================================================
 031                                       ;;; Check if char is a valid hex digit and convert it to a LSB nibble if it is
 031                                       ;; C=1 for valid, C=0 for invalid
 031                                       ;; load char from s0 (will be lost)
 031                                       ;; returns nibble in s0
 031                                       ;; uses s0
 031                                       ;;; ============================================================================
 031                  util_char_to_nibble: 
 031  19030                                SUB s0, 30                                       ; Drop s0 to 0-9 if the number was ascii 0-9
 032                                       ;; if some lower character, throw an error
 032  3A03F                                JUMP C, 03F[util_char_to_nibble_error]
 033  1D00A                                COMPARE s0, 0A                                   ; check for 0-9
 034                                       ;; jump to finish if nibble in range 0-9
 034  3A042                                JUMP C, 042[util_char_to_nibble_finish]
 035  19011                                SUB s0, 11                                       ; Move ASCII A to zero and see if we roll over
 036                                       ;; if some lower character, throw an error
 036  3A03F                                JUMP C, 03F[util_char_to_nibble_error]
 037  1100A                                ADD s0, 0A                                       ; add 10 to bring ascii A-F to dec 10-15
 038  1D010                                COMPARE s0, 10                                   ; compare to dec 16
 039                                       ;; Jump to finish if nibble in range A-F
 039  3A042                                JUMP C, 042[util_char_to_nibble_finish]
 03A  1902A                                SUB s0, 2A                                       ; bring ASCII a-f to dec 0-5
 03B                                       ;; if some lower character, throw an error
 03B  3A03F                                JUMP C, 03F[util_char_to_nibble_error]
 03C  1100A                                ADD s0, 0A                                       ; bring a-f to 10-15
 03D  1D010                                COMPARE s0, 10                                   ; compare to dec 16
 03E                                       ;; Jump to finish if nibble in range a-f
 03E  3A042                                JUMP C, 042[util_char_to_nibble_finish]
 03F                                       ;; other values are errors
 03F            util_char_to_nibble_error: 
 03F                                       ;; conversion failed, return s0=0 and C = 0
 03F  01000                                LOAD s0, 00
 040  1400E                                SR0 s0
 041  25000                                RETURN 
 042           util_char_to_nibble_finish: 
 042                                       ;; by my 1337 skillz (AKA: pure luck as I get to the part in the code),
 042                                       ;; C already is 1 and s0 is set... so return!
 042  25000                                RETURN 
 043                                       ;;; ============================================================================
 043                                       ;;; Convert one byte into two bytes of ASCII hex
 043                                       ;; loads s0
 043                                       ;; outputs s2,s1
 043                                       ;;; ============================================================================
 043                     util_byte_to_hex: 
 043                                       ;; convert MSNibble
 043  00200                                LOAD s2, s0
 044  1420E                                SR0 s2
 045  1420E                                SR0 s2
 046  1420E                                SR0 s2
 047  1420E                                SR0 s2
 048  11237                                ADD s2, 37                                       ; convert to A-F
 049  1D241                                COMPARE s2, 41
 04A                                       ;; If this wasn't a-F (ie 0-9) it will greater than 40
 04A  3E04D                                JUMP NC, 04D[util_byte_to_hex_next]
 04B  3204D                                JUMP Z, 04D[util_byte_to_hex_next]
 04C  19207                                SUB s2, 07                                       ; convert to 0-9
 04D                util_byte_to_hex_next: 
 04D  00100                                LOAD s1, s0
 04E  0310F                                AND s1, 0F                                       ; convert to LSNibble
 04F  11137                                ADD s1, 37                                       ; convert to A-F
 050  1D141                                COMPARE s1, 41                                   ; check if this is really A-F
 051  3E054                                JUMP NC, 054[util_byte_to_hex_end]
 052  32054                                JUMP Z, 054[util_byte_to_hex_end]
 053  19107                                SUB s1, 07                                       ; convert to 0-9
 054                 util_byte_to_hex_end: 
 054  25000                                RETURN 
 055                                       ;;; ============================================================================
 055                                       ;;; Convert one byte into two bytes of ASCII hex
 055                                       ;; loads s0
 055                                       ;; outputs s2,s1
 055                                       ;;; ============================================================================
 055                  util_print_hex_byte: 
 055  20043                                CALL 043[util_byte_to_hex]
 056  20002                                CALL 002[uart_output_wait]
 057  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 058  20002                                CALL 002[uart_output_wait]
 059  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 05A  25000                                RETURN 
 05B                                       ;;; ============================================================================
 05B                                       ;;; Write a new line on the UART screen
 05B                                       ;;; ============================================================================
 05B                       util_print_EOL: 
 05B  0110D                                LOAD s1, 0D                                      ; CR
 05C  20002                                CALL 002[uart_output_wait]
 05D  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 05E  0110A                                LOAD s1, 0A                                      ; LF
 05F  20002                                CALL 002[uart_output_wait]
 060  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 061  25000                                RETURN 
 062                                       ;;; ============================================================================
 062                                       ;;; Output the CLI prompt
 062                                       ;;; ============================================================================
 062                    util_print_prompt: 
 062  20002                                CALL 002[uart_output_wait]                       ; prompt
 063  0113E                                LOAD s1, 3E[">"]
 064  2D101                                OUTPUT s1, 01[UART_OUTPUT]                       ; echo
 065  25000                                RETURN 
 066                                       ;;; ============================================================================
 066                                       ;;; Prints a NULL terminated string @ sB,sA
 066                                       ;;  uses s1,sA,sB
 066                                       ;;; ============================================================================
 066                    util_print_string: 
 066  24BA0                                CALL@ (sB, sA)
 067  1D100                                COMPARE s1, 00
 068  3206E                                JUMP Z, 06E[util_print_string_end]               ; jump to finish if we get 00
 069  20002                                CALL 002[uart_output_wait]                       ; print currenc char to screen
 06A  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 06B  11A01                                ADD sA, 01                                       ; move forward in our string
 06C  13B00                                ADDCY sB, 00
 06D  22066                                JUMP 066[util_print_string]
 06E                util_print_string_end: 
 06E  25000                                RETURN 
 06F                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\spi.psm"["spi.psm"]
 06F                                       ;;; ============================================================================
 06F                                       ;;; Register map
 06F                                       ;;; ============================================================================
 06F                                       ;;; | name                | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 06F                                       ;;; | send_spi            |    |    |    |    |    |    | x  | x  | x  |    |    |    |
 06F  01710                      send_spi: LOAD s7, 10
 070  006C0                      next_bit: LOAD s6, sC[SPI_HIGH]
 071  03680                                AND s6, 80[spi_mosi]
 072  2D603                                OUTPUT s6, 03[SPI_PORT]
 073  14D06                                SL0 sD[SPI_LOW]
 074  14C00                                SLA sC[SPI_HIGH]
 075  2007D                                CALL 07D[clock_pulse]
 076  19701                                SUB s7, 01
 077  36070                                JUMP NZ, 070[next_bit]
 078  01602                                LOAD s6, 02[spi_cs]
 079  05601                                OR s6, 01[spi_clk]
 07A  2D603                                OUTPUT s6, 03[SPI_PORT]
 07B  20085                                CALL 085[sdelay]
 07C  25000                                RETURN 
 07D                          clock_pulse: 
 07D  05601                                OR s6, 01[spi_clk]
 07E  20085                                CALL 085[sdelay]
 07F  2D603                                OUTPUT s6, 03[SPI_PORT]
 080  036FE                                AND s6, FE[~spi_clk]
 081  20085                                CALL 085[sdelay]
 082  2D603                                OUTPUT s6, 03[SPI_PORT]
 083  20085                                CALL 085[sdelay]
 084  25000                                RETURN 
 085                               sdelay: 
 085  01840                                LOAD s8, 40
 086  22087                                JUMP 087[DLOOP]
 087                                DLOOP: 
 087  19801                                SUB s8, 01
 088  36087                                JUMP NZ, 087[DLOOP]
 089  25000                                RETURN 
 08A                                       ;;; ============================================================================
 08A                                       ;;; Reset the hardware and software to initial conditions
 08A                                       ;; uses s0 - s1
 08A                                       ;;; ============================================================================
 08A                                       STRING startup$, "CLI V:"
 08A                          str_startup: 
 08A  21143                                LOAD&RETURN s1, 43[startup$:"C"]
 08B  2114C                                LOAD&RETURN s1, 4C[startup$:"L"]
 08C  21149                                LOAD&RETURN s1, 49[startup$:"I"]
 08D  21120                                LOAD&RETURN s1, 20[startup$:" "]
 08E  21156                                LOAD&RETURN s1, 56[startup$:"V"]
 08F  2113A                                LOAD&RETURN s1, 3A[startup$:":"]
 090  21100                                LOAD&RETURN s1, 00
 091                           hard_reset: 
 091  200A0                                CALL 0A0[soft_reset]
 092                                       ;; reset UART
 092  2B031                                OUTPUTK 03, 1[UART_OUTPUT]
 093  2B001                                OUTPUTK 00, 1[UART_OUTPUT]
 094                                       ;; print version
 094  01B00                                LOAD sB, 00[str_startup'upper]
 095  01A8A                                LOAD sA, 8A[str_startup'lower]
 096  20066                                CALL 066[util_print_string]
 097  01001                                LOAD s0, 01[UI_VERSION]
 098  20043                                CALL 043[util_byte_to_hex]
 099  20002                                CALL 002[uart_output_wait]
 09A  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 09B  20002                                CALL 002[uart_output_wait]
 09C  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 09D  2005B                                CALL 05B[util_print_EOL]
 09E  20062                                CALL 062[util_print_prompt]
 09F  25000                                RETURN 
 0A0                                       ;;; ============================================================================
 0A0                                       ;;; Reset the software to initial conditions
 0A0                                       ;; uses s0
 0A0                                       ;;; ============================================================================
 0A0                           soft_reset: 
 0A0                                       ;; reset UART Buffer
 0A0  01000                                LOAD s0, 00
 0A1  2F020                                STORE s0, 20[CLI_BUFFER]
 0A2  2F023                                STORE s0, 23[CLI_COUNT]
 0A3  25000                                RETURN 
 0A4                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds.psm"["cmds.psm"]
 0A4                                       ;;; ============================================================================
 0A4                                       ;;; Register map
 0A4                                       ;;; ============================================================================
 0A4                                       ;;; | name                | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0A4                                       ;;; | cmd_find            | x  | x  | x  | x  |    |    |    |    |    |    | x  | x  |
 0A4                                       ;;; | cmd_tokenize        | x  | x  | x  | x  |    |    |    |    |    |    |    |    |
 0A4                                       ;;; | cmd_invalid   | x  | x  |    |    |    |    |    |    |    |    | x  | x  |
 0A4                                       ;;; | cmd_Error    | x  | x  | x  |    |    |    |    |    |    |    | x  | x  |
 0A4                                       ;;; | cmd_parse_tokens    | x  | x  | x  | x  | x  | x  | x  | x  |    |    |    |    |
 0A4                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmd_names.psm"["cmd_names.psm"]
 0A4                                       ;;; ============================================================================
 0A4                                       ;;; Register map
 0A4                                       ;;; ============================================================================
 0A4                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0A4                                       ;;; | cmds       |    | x  |    |    |    |    |    |    |    |    |    |    |
 0A4                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_C.psm"["cmds_C.psm"]
 0A4                                       ;;; ============================================================================
 0A4                                       ;;; Register map
 0A4                                       ;;; ============================================================================
 0A4                                       ;;; | name          | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0A4                                       ;;; | CMD_channel   | x  | x  |    |    | x  |    |    |    |    |    |    |    |
 0A4                                       ;;; | CMD_con_start | x  |    |    |    |    |    |    |    |    |    |    |    |
 0A4                                       ;;; | CMD_con_stop  | x  |    |    |    |    |    |    |    |    |    |    |    |
 0A4                          CMD_channel: 
 0A4  0B02C                                FETCH s0, 2C[CLI_WORD_1]
 0A5  14006                                SL0 s0
 0A6  14006                                SL0 s0                                           ;shift address into place
 0A7  00400                                LOAD s4, s0                                      ;store address
 0A8  05480                                OR s4, 80                                        ;lsb
 0A9  01130                                LOAD s1, 30[CLI_WORD_2]                          ;pointer
 0AA  0A010                                FETCH s0, (s1)                                   ;fetch lsb of channel period
 0AB  2C040                                OUTPUT s0, (s4)                                  ;output lsb
 0AC  11401                                ADD s4, 01                                       ;next byte of address
 0AD  11101                                ADD s1, 01                                       ;next byte of channel period
 0AE  0A010                                FETCH s0, (s1)
 0AF  2C040                                OUTPUT s0, (s4)                                  ;middle byte
 0B0  11401                                ADD s4, 01
 0B1  11101                                ADD s1, 01                                       ;msb, 0X
 0B2  0A010                                FETCH s0, (s1)
 0B3  2C040                                OUTPUT s0, (s4)                                  ;msb
 0B4  25000                                RETURN 
 0B5                       CMD_cont_start: 
 0B5  010FF                                LOAD s0, FF
 0B6  2D008                                OUTPUT s0, 08[INITPORT]
 0B7  25000                                RETURN 
 0B8                        CMD_cont_stop: 
 0B8  01000                                LOAD s0, 00
 0B9  2D008                                OUTPUT s0, 08[INITPORT]
 0BA  25000                                RETURN 
 0BB                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_D.psm"["cmds_D.psm"]
 0BB                                       ;;; ============================================================================
 0BB                                       ;;; Register map
 0BB                                       ;;; ============================================================================
 0BB                                       ;;; | name         | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0BB                                       ;;; | CMD_dac      | x  |    |    |    |    |    |    |    |    |    |    |    |
 0BB                              CMD_dac: 
 0BB  0102C                                LOAD s0, 2C[CLI_WORD_1]
 0BC  0AD00                                FETCH sD[SPI_LOW], (s0)
 0BD  11001                                ADD s0, 01
 0BE  0AC00                                FETCH sC[SPI_HIGH], (s0)
 0BF  2006F                                CALL 06F[send_spi]
 0C0  25000                                RETURN 
 0C1                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_F.psm"["cmds_F.psm"]
 0C1                                       ;;; ============================================================================
 0C1                                       ;;; Register map
 0C1                                       ;;; ============================================================================
 0C1                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0C1                                       ;;; | CMD_fire   | x  |    |    |    |    |    |    |    |    |    |    |    |
 0C1                             CMD_fire: 
 0C1  010FF                                LOAD s0, FF
 0C2  2D009                                OUTPUT s0, 09[ONCEPORT]
 0C3  01000                                LOAD s0, 00
 0C4  2D009                                OUTPUT s0, 09[ONCEPORT]
 0C5  25000                                RETURN 
 0C6                       CMD_FIFO_flags: 
 0C6  09004                                INPUT s0, 04[FIFO_flags]
 0C7  20055                                CALL 055[util_print_hex_byte]
 0C8  2005B                                CALL 05B[util_print_EOL]
 0C9  25000                                RETURN 
 0CA                        CMD_FIFO_read: 
 0CA  0B023                                FETCH s0, 23[CLI_COUNT]
 0CB  1D001                                COMPARE s0, 01
 0CC  320D0                                JUMP Z, 0D0[FIFO_read_len]
 0CD                        FIFO_read_all: 
 0CD  01700                                LOAD s7, 00                                      ;set count 0020 by default
 0CE  01620                                LOAD s6, 20
 0CF  220D4                                JUMP 0D4[do_D_init_read]
 0D0                        FIFO_read_len: 
 0D0  0102C                                LOAD s0, 2C[CLI_WORD_1]
 0D1  0A600                                FETCH s6, (s0)
 0D2  11001                                ADD s0, 01
 0D3  0A700                                FETCH s7, (s0)
 0D4                       do_D_init_read: 
 0D4  01801                                LOAD s8, 01                                      ;byte counter
 0D5  0103C                                LOAD s0, 3C                                      ; write K.28.1 word that is missed by the FIFO
 0D6  20055                                CALL 055[util_print_hex_byte]
 0D7                            do_D_read: 
 0D7  09004                                INPUT s0, 04[FIFO_flags]
 0D8  03001                                AND s0, 01
 0D9  360E4                                JUMP NZ, 0E4[do_D_empty]                         ;go if empty
 0DA  09003                                INPUT s0, 03[FIFO_data]
 0DB  20055                                CALL 055[util_print_hex_byte]
 0DC  11801                                ADD s8, 01                                       ;increment byte coutner
 0DD  03803                                AND s8, 03                                       ;check module 4
 0DE  360D7                                JUMP NZ, 0D7[do_D_read]
 0DF  2005B                                CALL 05B[util_print_EOL]                         ;send CR after 4 bytes
 0E0  19601                                SUB s6, 01[1'd]                                  ;decrement word count
 0E1  1B700                                SUBCY s7, 00[0'd]
 0E2  360D7                                JUMP NZ, 0D7[do_D_read]
 0E3  25000                                RETURN 
 0E4                           do_D_empty: 
 0E4  01058                                LOAD s0, 58
 0E5  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 0E6  2005B                                CALL 05B[util_print_EOL]
 0E7  25000                                RETURN 
 0E8                       CMD_FIFO_reset: 
 0E8  2D0E2                                OUTPUT s0, E2[RESET_fifo_port]
 0E9  01F00                                LOAD sF, 00
 0EA  2DF02                                OUTPUT sF, 02[LED_PORT]
 0EB  25000                                RETURN 
 0EC                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_G.psm"["cmds_G.psm"]
 0EC                                       ;;; ============================================================================
 0EC                                       ;;; Register map
 0EC                                       ;;; ============================================================================
 0EC                                       ;;; | name          | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0EC                                       ;;; | CMD_GEN_C5    | x  | x  |    |    |    |    |    |    |    |    |    |    |
 0EC                           CMD_GEN_C5: 
 0EC  0B02C                                FETCH s0, 2C[CLI_WORD_1]
 0ED  05010                                OR s0, 10                                        ;set bit 4 for C code
 0EE  2D0E0                                OUTPUT s0, E0[C5_data]
 0EF  25000                                RETURN 
 0F0                           CMD_GEN_D5: 
 0F0  0B02C                                FETCH s0, 2C[CLI_WORD_1]
 0F1  2D0E0                                OUTPUT s0, E0[C5_data]
 0F2  25000                                RETURN 
 0F3                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_H.psm"["cmds_H.psm"]
 0F3                                       ;;; ============================================================================
 0F3                                       ;;; Register map
 0F3                                       ;;; ============================================================================
 0F3                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0F3                                       ;;; | CMD_help   | x  | x  |    |    |    |    |    |    |    |    | x  |  x |
 0F3                                       ;;; ============================================================================
 0F3                                       ;;; Print Help functions
 0F3                                       ;; uses sA-sB, s1
 0F3                                       ;;; ============================================================================
 0F3                             CMD_help: 
 0F3  01B02                                LOAD sB, 02[cmds'upper]
 0F4  01A08                                LOAD sA, 08[cmds'lower]
 0F5                        CMD_help_loop: 
 0F5                                       ;; loop over commands
 0F5  24BA0                                CALL@ (sB, sA)                                   ; load next CMDs char into s1
 0F6  1D100                                COMPARE s1, 00                                   ; check for end of command
 0F7  320FF                                JUMP Z, 0FF[CMD_help_eol]
 0F8  1D1FF                                COMPARE s1, FF                                   ; check for no more commands
 0F9  32103                                JUMP Z, 103[CMD_help_end]
 0FA  20002                                CALL 002[uart_output_wait]
 0FB  2D101                                OUTPUT s1, 01[UART_OUTPUT]                       ; print char
 0FC  11A01                                ADD sA, 01                                       ; move forward
 0FD  13B00                                ADDCY sB, 00
 0FE  220F5                                JUMP 0F5[CMD_help_loop]
 0FF                         CMD_help_eol: 
 0FF  2005B                                CALL 05B[util_print_EOL]                         ; print EOL
 100  11A03                                ADD sA, 03                                       ; move forwardpast the function address
 101  13B00                                ADDCY sB, 00
 102  220F5                                JUMP 0F5[CMD_help_loop]
 103                         CMD_help_end: 
 103  2005B                                CALL 05B[util_print_EOL]
 104  25000                                RETURN 
 105                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_M.psm"["cmds_M.psm"]
 105                                       ;;; ============================================================================
 105                                       ;;; Register map
 105                                       ;;; ============================================================================
 105                                       ;;; | name         | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 105                                       ;;; | CMD_Mem_dump | x  | x  | x  | x  |    |    |    |    |    |    | x  |  x |
 105                                       ;;; | CMD_multiarg | x  | x  | x  | x  | x  | x  | x  |    |    |    | x  |  x |
 105                                       ;;; DUMP data to user
 105                                       ;; 1) write size of data in memory
 105                                       ;; 2) Write data
 105                                       ;; 3) Write CMD_DUMP
 105                                       ;;; ============================================================================
 105                         CMD_Mem_dump: 
 105  01300                                LOAD s3, 00                                      ; initialize read pointer
 106                    CMD_Mem_dump_loop: 
 106                                       ;; print offset
 106  00030                                LOAD s0, s3
 107  20043                                CALL 043[util_byte_to_hex]
 108  20002                                CALL 002[uart_output_wait]
 109  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 10A  20002                                CALL 002[uart_output_wait]
 10B  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 10C                                       ;; print ": "
 10C  20002                                CALL 002[uart_output_wait]
 10D  0103A                                LOAD s0, 3A[":"]
 10E  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 10F  20002                                CALL 002[uart_output_wait]
 110  01020                                LOAD s0, 20[" "]
 111  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 112                                       ;; print 4 bytes of data
 112               CMD_Mem_dump_line_loop: 
 112  0A030                                FETCH s0, (s3)                                   ; fetch data
 113  20043                                CALL 043[util_byte_to_hex]
 114  20002                                CALL 002[uart_output_wait]
 115  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 116  20002                                CALL 002[uart_output_wait]
 117  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 118                                       ;; check for end of the buffer
 118  1D3FF                                COMPARE s3, FF[MEM_SIZE]                         ; see if we are past valid memory
 119  32121                                JUMP Z, 121[CMD_Mem_dump_end]
 11A                                       ;; backup last printed pointer
 11A  00030                                LOAD s0, s3
 11B  11301                                ADD s3, 01                                       ;move forward in pointer
 11C                                       ;; determine if we are at the 4 byte line boundary
 11C  03003                                AND s0, 03
 11D  1D003                                COMPARE s0, 03
 11E  36112                                JUMP NZ, 112[CMD_Mem_dump_line_loop]
 11F                                       ;; print EOL after 4 bytes
 11F  2005B                                CALL 05B[util_print_EOL]
 120  22106                                JUMP 106[CMD_Mem_dump_loop]
 121                     CMD_Mem_dump_end: 
 121  2005B                                CALL 05B[util_print_EOL]
 122  25000                                RETURN 
 123                         CMD_multiarg: 
 123  2017C                                CALL 17C[CMD_sys]
 124  0B023                                FETCH s0, 23[CLI_COUNT]                          ; load the already parsed commands
 125  1D004                                COMPARE s0, 04                                   ; jump to the end if we have fewer than 4 args
 126  3A12D                                JUMP C, 12D[CMD_multiarg_end]
 127                                       ;; reparse the reset of the args
 127                                       ;; get CMD4's postions
 127  0B227                                FETCH s2, 27[CLI_WORD_4_POS]
 128                                       ;; get CMD4's size
 128  0B12B                                FETCH s1, 2B[CLI_WORD_4_SIZE]
 129  10210                                ADD s2, s1
 12A                                       ;; computer new end pos
 12A  202AA                                CALL 2AA[cmd_tokenize]
 12B  202F9                                CALL 2F9[cmd_parse_tokens]
 12C  2017C                                CALL 17C[CMD_sys]
 12D                     CMD_multiarg_end: 
 12D  25000                                RETURN 
 12E                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_P.psm"["cmds_P.psm"]
 12E                                       ;;; ============================================================================
 12E                                       ;;; Register map
 12E                                       ;;; ============================================================================
 12E                                       ;;; | name             | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 12E                                       ;;; | CMD_period       | x  | x  |    |    | x  |    |    |    |    |    |    |    |
 12E                                       ;;; | CMD_pulse_period | x  | x  |    |    | x  |    |    |    |    |    |    |    |
 12E                           CMD_period: 
 12E  01440                                LOAD s4, 40                                      ;store address
 12F  0112C                                LOAD s1, 2C[CLI_WORD_1]                          ;pointer
 130  0A010                                FETCH s0, (s1)                                   ;fetch lsb of channel period
 131  2C040                                OUTPUT s0, (s4)                                  ;output lsb
 132  11401                                ADD s4, 01                                       ;next byte of address
 133  11101                                ADD s1, 01                                       ;next byte of channel period
 134  0A010                                FETCH s0, (s1)
 135  2C040                                OUTPUT s0, (s4)                                  ;middle byte
 136  11401                                ADD s4, 01
 137  11101                                ADD s1, 01                                       ;msb
 138  0A010                                FETCH s0, (s1)
 139  2C040                                OUTPUT s0, (s4)                                  ;msb
 13A  25000                                RETURN 
 13B                     CMD_pulse_period: 
 13B  01444                                LOAD s4, 44                                      ;store address
 13C  0112C                                LOAD s1, 2C[CLI_WORD_1]                          ;pointer
 13D  0A010                                FETCH s0, (s1)                                   ;fetch lsb of channel period
 13E  2C040                                OUTPUT s0, (s4)                                  ;output lsb
 13F  11401                                ADD s4, 01                                       ;next byte of address
 140  11101                                ADD s1, 01                                       ;next byte of channel period
 141  0A010                                FETCH s0, (s1)
 142  2C040                                OUTPUT s0, (s4)                                  ;middle byte
 143  11401                                ADD s4, 01
 144  11101                                ADD s1, 01                                       ;msb
 145  0A010                                FETCH s0, (s1)
 146  2C040                                OUTPUT s0, (s4)                                  ;msb
 147  25000                                RETURN 
 148                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_R.psm"["cmds_R.psm"]
 148                                       ;;; ============================================================================
 148                                       ;;; Register map
 148                                       ;;; ============================================================================
 148                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 148                                       ;;; | CMD_reset  | x  | x  | x  |    |    |    |    |    |    |    | x  |  x |
 148                                       ;;; ============================================================================
 148                                       ;;; Reset UI
 148                                       ;;; ============================================================================
 148                            CMD_reset: 
 148  20091                                CALL 091[hard_reset]
 149  25000                                RETURN 
 14A                         CMD_rapid_on: 
 14A  010FF                                LOAD s0, FF
 14B  2D009                                OUTPUT s0, 09[ONCEPORT]
 14C  25000                                RETURN 
 14D                        CMD_rapid_off: 
 14D  01000                                LOAD s0, 00
 14E  2D009                                OUTPUT s0, 09[ONCEPORT]
 14F  25000                                RETURN 
 150                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_S.psm"["cmds_S.psm"]
 150                                       ;;; ============================================================================
 150                                       ;;; Register map
 150                                       ;;; ============================================================================
 150                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 150                                       ;;; | CMD_sys    | x  | x  | x  | x  | x  | x  | x  |    |    |    | x  |  x |
 150                                       STRING BUFFER$, "Buffer: "
 150                                       STRING WORD_COUNT$, "Word count: "
 150                                       STRING WORD_SIZE$, "Word sizes:    "
 150                                       STRING WORD$, "Word "
 150                           str_BUFFER: 
 150  21142                                LOAD&RETURN s1, 42[BUFFER$:"B"]
 151  21175                                LOAD&RETURN s1, 75[BUFFER$:"u"]
 152  21166                                LOAD&RETURN s1, 66[BUFFER$:"f"]
 153  21166                                LOAD&RETURN s1, 66[BUFFER$:"f"]
 154  21165                                LOAD&RETURN s1, 65[BUFFER$:"e"]
 155  21172                                LOAD&RETURN s1, 72[BUFFER$:"r"]
 156  2113A                                LOAD&RETURN s1, 3A[BUFFER$:":"]
 157  21120                                LOAD&RETURN s1, 20[BUFFER$:" "]
 158  21100                                LOAD&RETURN s1, 00
 159                       str_WORD_COUNT: 
 159  21157                                LOAD&RETURN s1, 57[WORD_COUNT$:"W"]
 15A  2116F                                LOAD&RETURN s1, 6F[WORD_COUNT$:"o"]
 15B  21172                                LOAD&RETURN s1, 72[WORD_COUNT$:"r"]
 15C  21164                                LOAD&RETURN s1, 64[WORD_COUNT$:"d"]
 15D  21120                                LOAD&RETURN s1, 20[WORD_COUNT$:" "]
 15E  21163                                LOAD&RETURN s1, 63[WORD_COUNT$:"c"]
 15F  2116F                                LOAD&RETURN s1, 6F[WORD_COUNT$:"o"]
 160  21175                                LOAD&RETURN s1, 75[WORD_COUNT$:"u"]
 161  2116E                                LOAD&RETURN s1, 6E[WORD_COUNT$:"n"]
 162  21174                                LOAD&RETURN s1, 74[WORD_COUNT$:"t"]
 163  2113A                                LOAD&RETURN s1, 3A[WORD_COUNT$:":"]
 164  21120                                LOAD&RETURN s1, 20[WORD_COUNT$:" "]
 165  21100                                LOAD&RETURN s1, 00
 166                        str_WORD_SIZE: 
 166  21157                                LOAD&RETURN s1, 57[WORD_SIZE$:"W"]
 167  2116F                                LOAD&RETURN s1, 6F[WORD_SIZE$:"o"]
 168  21172                                LOAD&RETURN s1, 72[WORD_SIZE$:"r"]
 169  21164                                LOAD&RETURN s1, 64[WORD_SIZE$:"d"]
 16A  21120                                LOAD&RETURN s1, 20[WORD_SIZE$:" "]
 16B  21173                                LOAD&RETURN s1, 73[WORD_SIZE$:"s"]
 16C  21169                                LOAD&RETURN s1, 69[WORD_SIZE$:"i"]
 16D  2117A                                LOAD&RETURN s1, 7A[WORD_SIZE$:"z"]
 16E  21165                                LOAD&RETURN s1, 65[WORD_SIZE$:"e"]
 16F  21173                                LOAD&RETURN s1, 73[WORD_SIZE$:"s"]
 170  2113A                                LOAD&RETURN s1, 3A[WORD_SIZE$:":"]
 171  21120                                LOAD&RETURN s1, 20[WORD_SIZE$:" "]
 172  21120                                LOAD&RETURN s1, 20[WORD_SIZE$:" "]
 173  21120                                LOAD&RETURN s1, 20[WORD_SIZE$:" "]
 174  21120                                LOAD&RETURN s1, 20[WORD_SIZE$:" "]
 175  21100                                LOAD&RETURN s1, 00
 176                             str_WORD: 
 176  21157                                LOAD&RETURN s1, 57[WORD$:"W"]
 177  2116F                                LOAD&RETURN s1, 6F[WORD$:"o"]
 178  21172                                LOAD&RETURN s1, 72[WORD$:"r"]
 179  21164                                LOAD&RETURN s1, 64[WORD$:"d"]
 17A  21120                                LOAD&RETURN s1, 20[WORD$:" "]
 17B  21100                                LOAD&RETURN s1, 00
 17C                                       ;;; ============================================================================
 17C                                       ;;; Prints system area of scratchpad to the screen for debugging
 17C                                       ;; uses sA,sB,s0,s1,s2,s3,s4,s5,s6
 17C                                       ;;; ============================================================================
 17C                              CMD_sys: 
 17C                                       ;; print CLI buffer
 17C  01B01                                LOAD sB, 01[str_BUFFER'upper]
 17D  01A50                                LOAD sA, 50[str_BUFFER'lower]
 17E  20066                                CALL 066[util_print_string]
 17F                                       ;; load values from buffer to print
 17F  01100                                LOAD s1, 00[CLI_BUFFER_START]
 180  0B220                                FETCH s2, 20[CLI_BUFFER]
 181                       CMD_sys_buffer: 
 181  1C120                                COMPARE s1, s2
 182  3E188                                JUMP NC, 188[CMD_sys_buffer_size]                ;when we are done with the buffer, jump to word count
 183  20002                                CALL 002[uart_output_wait]
 184  0A010                                FETCH s0, (s1)
 185  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 186  11101                                ADD s1, 01
 187  22181                                JUMP 181[CMD_sys_buffer]
 188                  CMD_sys_buffer_size: 
 188  20002                                CALL 002[uart_output_wait]
 189  01020                                LOAD s0, 20[" "]
 18A  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 18B  20002                                CALL 002[uart_output_wait]
 18C  01028                                LOAD s0, 28["("]
 18D  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 18E  00020                                LOAD s0, s2
 18F  20043                                CALL 043[util_byte_to_hex]
 190  20002                                CALL 002[uart_output_wait]
 191  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 192  20002                                CALL 002[uart_output_wait]
 193  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 194  20002                                CALL 002[uart_output_wait]
 195  01029                                LOAD s0, 29[")"]
 196  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 197  2005B                                CALL 05B[util_print_EOL]
 198                   CMD_sys_word_count: 
 198                                       ;; print word count
 198  01B01                                LOAD sB, 01[str_WORD_COUNT'upper]
 199  01A59                                LOAD sA, 59[str_WORD_COUNT'lower]
 19A  20066                                CALL 066[util_print_string]
 19B  20002                                CALL 002[uart_output_wait]
 19C  0B023                                FETCH s0, 23[CLI_COUNT]
 19D  20043                                CALL 043[util_byte_to_hex]
 19E  20002                                CALL 002[uart_output_wait]
 19F  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 1A0  20002                                CALL 002[uart_output_wait]
 1A1  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 1A2  0B423                                FETCH s4, 23[CLI_COUNT]
 1A3  01300                                LOAD s3, 00
 1A4                     CMD_sys_word_pos: 
 1A4  1C340                                COMPARE s3, s4
 1A5  3E1B6                                JUMP NC, 1B6[CMD_sys_word_size]
 1A6  20002                                CALL 002[uart_output_wait]
 1A7  01020                                LOAD s0, 20[" "]
 1A8  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 1A9  20002                                CALL 002[uart_output_wait]
 1AA  01040                                LOAD s0, 40["@"]
 1AB  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 1AC  01124                                LOAD s1, 24[CLI_WORD_1_POS]
 1AD  10130                                ADD s1, s3
 1AE  0A010                                FETCH s0, (s1)
 1AF  20043                                CALL 043[util_byte_to_hex]
 1B0  20002                                CALL 002[uart_output_wait]
 1B1  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 1B2  20002                                CALL 002[uart_output_wait]
 1B3  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 1B4  11301                                ADD s3, 01
 1B5  221A4                                JUMP 1A4[CMD_sys_word_pos]
 1B6                    CMD_sys_word_size: 
 1B6  2005B                                CALL 05B[util_print_EOL]
 1B7                                       ;; print word size
 1B7  01B01                                LOAD sB, 01[str_WORD_SIZE'upper]
 1B8  01A66                                LOAD sA, 66[str_WORD_SIZE'lower]
 1B9  20066                                CALL 066[util_print_string]
 1BA  0B423                                FETCH s4, 23[CLI_COUNT]
 1BB  01300                                LOAD s3, 00
 1BC               CMD_sys_word_size_loop: 
 1BC  1C340                                COMPARE s3, s4
 1BD  3E1CB                                JUMP NC, 1CB[CMD_sys_word]
 1BE  20002                                CALL 002[uart_output_wait]
 1BF  01020                                LOAD s0, 20[" "]
 1C0  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 1C1  01128                                LOAD s1, 28[CLI_WORD_1_SIZE]
 1C2  10130                                ADD s1, s3
 1C3  0A010                                FETCH s0, (s1)
 1C4  20043                                CALL 043[util_byte_to_hex]
 1C5  20002                                CALL 002[uart_output_wait]
 1C6  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 1C7  20002                                CALL 002[uart_output_wait]
 1C8  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 1C9  11301                                ADD s3, 01
 1CA  221BC                                JUMP 1BC[CMD_sys_word_size_loop]
 1CB                         CMD_sys_word: 
 1CB  2005B                                CALL 05B[util_print_EOL]
 1CC  0B423                                FETCH s4, 23[CLI_COUNT]
 1CD  01300                                LOAD s3, 00
 1CE                    CMD_sys_word_loop: 
 1CE  1C340                                COMPARE s3, s4
 1CF  3E1EE                                JUMP NC, 1EE[CMD_sys_word_end]
 1D0                                       ;; print word size
 1D0  2005B                                CALL 05B[util_print_EOL]
 1D1  01B01                                LOAD sB, 01[str_WORD'upper]
 1D2  01A76                                LOAD sA, 76[str_WORD'lower]
 1D3  20066                                CALL 066[util_print_string]
 1D4  00030                                LOAD s0, s3
 1D5  20043                                CALL 043[util_byte_to_hex]
 1D6  20002                                CALL 002[uart_output_wait]
 1D7  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 1D8  20002                                CALL 002[uart_output_wait]
 1D9  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 1DA  20002                                CALL 002[uart_output_wait]
 1DB  01020                                LOAD s0, 20[" "]
 1DC  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 1DD                                       ;; go to the offset for this word
 1DD  00530                                LOAD s5, s3
 1DE  11301                                ADD s3, 01
 1DF  14506                                SL0 s5
 1E0  14506                                SL0 s5
 1E1  1152C                                ADD s5, 2C[CLI_WORD_1]
 1E2  00650                                LOAD s6, s5
 1E3  11603                                ADD s6, 03
 1E4         CMD_sys_word_loop_print_loop: 
 1E4  1C650                                COMPARE s6, s5
 1E5  3A1CE                                JUMP C, 1CE[CMD_sys_word_loop]
 1E6  0A060                                FETCH s0, (s6)
 1E7  20043                                CALL 043[util_byte_to_hex]
 1E8  20002                                CALL 002[uart_output_wait]
 1E9  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 1EA  20002                                CALL 002[uart_output_wait]
 1EB  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 1EC  19601                                SUB s6, 01
 1ED  221E4                                JUMP 1E4[CMD_sys_word_loop_print_loop]
 1EE                     CMD_sys_word_end: 
 1EE  2005B                                CALL 05B[util_print_EOL]
 1EF  25000                                RETURN 
 1F0                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_T.psm"["cmds_T.psm"]
 1F0                                       ;;; ============================================================================
 1F0                                       ;;; Register map
 1F0                                       ;;; ============================================================================
 1F0                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 1F0                                       ;;; | cmds       |    | x  |    |    |    |    |    |    |    |    |    |    |
 1F0                     CMD_TDC_loopback: 
 1F0  0B02C                                FETCH s0, 2C[CLI_WORD_1]
 1F1  2D020                                OUTPUT s0, 20[CTRL_port]
 1F2  25000                                RETURN 
 1F3                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_V.psm"["cmds_V.psm"]
 1F3                                       ;;; ============================================================================
 1F3                                       ;;; Register map
 1F3                                       ;;; ============================================================================
 1F3                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 1F3                                       ;;; | hard_reset | x  | x  | x  |    |    |    |    |    |    |    | x  |  x |
 1F3                                       ;;; ============================================================================
 1F3                                       ;;; Prints "Ver: #" to UART
 1F3                                       ;; molests s0-s2
 1F3                                       ;;; ============================================================================
 1F3                                       STRING ver$, "Version: "
 1F3                              str_ver: 
 1F3  21156                                LOAD&RETURN s1, 56[ver$:"V"]
 1F4  21165                                LOAD&RETURN s1, 65[ver$:"e"]
 1F5  21172                                LOAD&RETURN s1, 72[ver$:"r"]
 1F6  21173                                LOAD&RETURN s1, 73[ver$:"s"]
 1F7  21169                                LOAD&RETURN s1, 69[ver$:"i"]
 1F8  2116F                                LOAD&RETURN s1, 6F[ver$:"o"]
 1F9  2116E                                LOAD&RETURN s1, 6E[ver$:"n"]
 1FA  2113A                                LOAD&RETURN s1, 3A[ver$:":"]
 1FB  21120                                LOAD&RETURN s1, 20[ver$:" "]
 1FC  21100                                LOAD&RETURN s1, 00
 1FD                          CMD_version: 
 1FD  01B01                                LOAD sB, 01[str_ver'upper]
 1FE  01AF3                                LOAD sA, F3[str_ver'lower]
 1FF  20066                                CALL 066[util_print_string]
 200  01001                                LOAD s0, 01[UI_VERSION]
 201  20043                                CALL 043[util_byte_to_hex]
 202  20002                                CALL 002[uart_output_wait]
 203  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 204  20002                                CALL 002[uart_output_wait]
 205  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 206  2005B                                CALL 05B[util_print_EOL]
 207  25000                                RETURN 
 208                                       STRING multiarg$, "multiarg"
 208                                       STRING memdump$, "memdump"
 208                                       STRING reset$, "reset"
 208                                       STRING version$, "version"
 208                                       STRING sys$, "sys"
 208                                       STRING help$, "help"
 208                                       STRING dac$, "d"
 208                                       STRING channel$, "c"
 208                                       STRING fire$, "s"
 208                                       STRING rapid_on$, "n"
 208                                       STRING rapid_off$, "m"
 208                                       ;; STRING pulse_help msg$, "h"
 208                                       STRING cont_start$, "a"
 208                                       STRING cont_stop$, "z"
 208                                       STRING period$, "p"
 208                                       STRING pulse_period$, "t"
 208                                       STRING GEN_C5$, "CC"
 208                                       STRING GEN_D5$, "CD"
 208                                       STRING FIFO_flags$, "F"
 208                                       STRING FIFO_read$, "D"
 208                                       STRING FIFO_reset$, "R"
 208                                       STRING TDC_loopback$, "M"
 208                                 cmds: 
 208                                       ;; CMD_multiarg (multiarg)
 208  2116D                                LOAD&RETURN s1, 6D[multiarg$:"m"]
 209  21175                                LOAD&RETURN s1, 75[multiarg$:"u"]
 20A  2116C                                LOAD&RETURN s1, 6C[multiarg$:"l"]
 20B  21174                                LOAD&RETURN s1, 74[multiarg$:"t"]
 20C  21169                                LOAD&RETURN s1, 69[multiarg$:"i"]
 20D  21161                                LOAD&RETURN s1, 61[multiarg$:"a"]
 20E  21172                                LOAD&RETURN s1, 72[multiarg$:"r"]
 20F  21167                                LOAD&RETURN s1, 67[multiarg$:"g"]
 210  21100                                LOAD&RETURN s1, 00                               ; end of command
 211  21101                                LOAD&RETURN s1, 01[CMD_multiarg'upper]
 212  21123                                LOAD&RETURN s1, 23[CMD_multiarg'lower]
 213                                       ;; CMD_Mem_dump (memdump)
 213  2116D                                LOAD&RETURN s1, 6D[memdump$:"m"]
 214  21165                                LOAD&RETURN s1, 65[memdump$:"e"]
 215  2116D                                LOAD&RETURN s1, 6D[memdump$:"m"]
 216  21164                                LOAD&RETURN s1, 64[memdump$:"d"]
 217  21175                                LOAD&RETURN s1, 75[memdump$:"u"]
 218  2116D                                LOAD&RETURN s1, 6D[memdump$:"m"]
 219  21170                                LOAD&RETURN s1, 70[memdump$:"p"]
 21A  21100                                LOAD&RETURN s1, 00                               ; end of command
 21B  21101                                LOAD&RETURN s1, 01[CMD_Mem_dump'upper]
 21C  21105                                LOAD&RETURN s1, 05[CMD_Mem_dump'lower]
 21D                                       ;; CMD_reset (reset)
 21D  21172                                LOAD&RETURN s1, 72[reset$:"r"]
 21E  21165                                LOAD&RETURN s1, 65[reset$:"e"]
 21F  21173                                LOAD&RETURN s1, 73[reset$:"s"]
 220  21165                                LOAD&RETURN s1, 65[reset$:"e"]
 221  21174                                LOAD&RETURN s1, 74[reset$:"t"]
 222  21100                                LOAD&RETURN s1, 00                               ; end of command
 223  21101                                LOAD&RETURN s1, 01[CMD_reset'upper]
 224  21148                                LOAD&RETURN s1, 48[CMD_reset'lower]
 225                                       ;; CMD_Version (version)
 225  21176                                LOAD&RETURN s1, 76[version$:"v"]
 226  21165                                LOAD&RETURN s1, 65[version$:"e"]
 227  21172                                LOAD&RETURN s1, 72[version$:"r"]
 228  21173                                LOAD&RETURN s1, 73[version$:"s"]
 229  21169                                LOAD&RETURN s1, 69[version$:"i"]
 22A  2116F                                LOAD&RETURN s1, 6F[version$:"o"]
 22B  2116E                                LOAD&RETURN s1, 6E[version$:"n"]
 22C  21100                                LOAD&RETURN s1, 00                               ; end of command
 22D  21101                                LOAD&RETURN s1, 01[CMD_version'upper]
 22E  211FD                                LOAD&RETURN s1, FD[CMD_version'lower]
 22F                                       ;; CMD_sys (sys)
 22F  21173                                LOAD&RETURN s1, 73[sys$:"s"]
 230  21179                                LOAD&RETURN s1, 79[sys$:"y"]
 231  21173                                LOAD&RETURN s1, 73[sys$:"s"]
 232  21100                                LOAD&RETURN s1, 00                               ; end of command
 233  21101                                LOAD&RETURN s1, 01[CMD_sys'upper]
 234  2117C                                LOAD&RETURN s1, 7C[CMD_sys'lower]
 235                                       ;; CMD_help (help)
 235  21168                                LOAD&RETURN s1, 68[help$:"h"]
 236  21165                                LOAD&RETURN s1, 65[help$:"e"]
 237  2116C                                LOAD&RETURN s1, 6C[help$:"l"]
 238  21170                                LOAD&RETURN s1, 70[help$:"p"]
 239  21100                                LOAD&RETURN s1, 00                               ; end of command
 23A  21100                                LOAD&RETURN s1, 00[CMD_help'upper]
 23B  211F3                                LOAD&RETURN s1, F3[CMD_help'lower]
 23C                                       ;; CMD_dac
 23C  21164                                LOAD&RETURN s1, 64[dac$:"d"]
 23D  21100                                LOAD&RETURN s1, 00                               ; end of command
 23E  21100                                LOAD&RETURN s1, 00[CMD_dac'upper]
 23F  211BB                                LOAD&RETURN s1, BB[CMD_dac'lower]
 240                                       ;; CMD_channel
 240  21163                                LOAD&RETURN s1, 63[channel$:"c"]
 241  21100                                LOAD&RETURN s1, 00                               ; end of command
 242  21100                                LOAD&RETURN s1, 00[CMD_channel'upper]
 243  211A4                                LOAD&RETURN s1, A4[CMD_channel'lower]
 244                                       ;; CMD_fire
 244  21173                                LOAD&RETURN s1, 73[fire$:"s"]
 245  21100                                LOAD&RETURN s1, 00                               ; end of command
 246  21100                                LOAD&RETURN s1, 00[CMD_fire'upper]
 247  211C1                                LOAD&RETURN s1, C1[CMD_fire'lower]
 248                                       ;; CMD_rapid_on
 248  2116E                                LOAD&RETURN s1, 6E[rapid_on$:"n"]
 249  21100                                LOAD&RETURN s1, 00                               ; end of command
 24A  21101                                LOAD&RETURN s1, 01[CMD_rapid_on'upper]
 24B  2114A                                LOAD&RETURN s1, 4A[CMD_rapid_on'lower]
 24C                                       ;; CMD_rapid_off
 24C  2116D                                LOAD&RETURN s1, 6D[rapid_off$:"m"]
 24D  21100                                LOAD&RETURN s1, 00                               ; end of command
 24E  21101                                LOAD&RETURN s1, 01[CMD_rapid_off'upper]
 24F  2114D                                LOAD&RETURN s1, 4D[CMD_rapid_off'lower]
 250                                       ;; CMD_cont_start
 250  21161                                LOAD&RETURN s1, 61[cont_start$:"a"]
 251  21100                                LOAD&RETURN s1, 00                               ; end of command
 252  21100                                LOAD&RETURN s1, 00[CMD_cont_start'upper]
 253  211B5                                LOAD&RETURN s1, B5[CMD_cont_start'lower]
 254                                       ;; CMD_cont_stop
 254  2117A                                LOAD&RETURN s1, 7A[cont_stop$:"z"]
 255  21100                                LOAD&RETURN s1, 00                               ; end of command
 256  21100                                LOAD&RETURN s1, 00[CMD_cont_stop'upper]
 257  211B8                                LOAD&RETURN s1, B8[CMD_cont_stop'lower]
 258                                       ;; CMD_period
 258  21170                                LOAD&RETURN s1, 70[period$:"p"]
 259  21100                                LOAD&RETURN s1, 00                               ; end of command
 25A  21101                                LOAD&RETURN s1, 01[CMD_period'upper]
 25B  2112E                                LOAD&RETURN s1, 2E[CMD_period'lower]
 25C                                       ;; CMD_pulse_period
 25C  21174                                LOAD&RETURN s1, 74[pulse_period$:"t"]
 25D  21100                                LOAD&RETURN s1, 00                               ; end of command
 25E  21101                                LOAD&RETURN s1, 01[CMD_pulse_period'upper]
 25F  2113B                                LOAD&RETURN s1, 3B[CMD_pulse_period'lower]
 260                                       ;; CMD_GEN_C5
 260  21143                                LOAD&RETURN s1, 43[GEN_C5$:"C"]
 261  21143                                LOAD&RETURN s1, 43[GEN_C5$:"C"]
 262  21100                                LOAD&RETURN s1, 00                               ; end of command
 263  21100                                LOAD&RETURN s1, 00[CMD_GEN_C5'upper]
 264  211EC                                LOAD&RETURN s1, EC[CMD_GEN_C5'lower]
 265                                       ;; CMD_GEN_D5
 265  21143                                LOAD&RETURN s1, 43[GEN_D5$:"C"]
 266  21144                                LOAD&RETURN s1, 44[GEN_D5$:"D"]
 267  21100                                LOAD&RETURN s1, 00                               ; end of command
 268  21100                                LOAD&RETURN s1, 00[CMD_GEN_D5'upper]
 269  211F0                                LOAD&RETURN s1, F0[CMD_GEN_D5'lower]
 26A                                       ;; CMD_FIFO_flags
 26A  21146                                LOAD&RETURN s1, 46[FIFO_flags$:"F"]
 26B  21100                                LOAD&RETURN s1, 00                               ; end of command
 26C  21100                                LOAD&RETURN s1, 00[CMD_FIFO_flags'upper]
 26D  211C6                                LOAD&RETURN s1, C6[CMD_FIFO_flags'lower]
 26E                                       ;; CMD_FIFO_read
 26E  21144                                LOAD&RETURN s1, 44[FIFO_read$:"D"]
 26F  21100                                LOAD&RETURN s1, 00                               ; end of command
 270  21100                                LOAD&RETURN s1, 00[CMD_FIFO_read'upper]
 271  211CA                                LOAD&RETURN s1, CA[CMD_FIFO_read'lower]
 272                                       ;; CMD_FIFO_reset
 272  21152                                LOAD&RETURN s1, 52[FIFO_reset$:"R"]
 273  21100                                LOAD&RETURN s1, 00                               ; end of command
 274  21100                                LOAD&RETURN s1, 00[CMD_FIFO_reset'upper]
 275  211E8                                LOAD&RETURN s1, E8[CMD_FIFO_reset'lower]
 276                                       ;; CMD_TDC_loopback
 276  2114D                                LOAD&RETURN s1, 4D[TDC_loopback$:"M"]
 277  21100                                LOAD&RETURN s1, 00                               ; end of command
 278  21101                                LOAD&RETURN s1, 01[CMD_TDC_loopback'upper]
 279  211F0                                LOAD&RETURN s1, F0[CMD_TDC_loopback'lower]
 27A  211FF                                LOAD&RETURN s1, FF                               ; end of commands string
 27B                                       ;;; ============================================================================
 27B                                       ;;; Find function to call, parse arguemtns and then call it
 27B                                       ;;; ============================================================================
 27B                             cmd_find: 
 27B  01B02                                LOAD sB, 02[cmds'upper]
 27C  01A08                                LOAD sA, 08[cmds'lower]
 27D  01200                                LOAD s2, 00[CLI_BUFFER_START]
 27E                        cmd_find_loop: 
 27E                                       ;; process next cmds char
 27E  24BA0                                CALL@ (sB, sA)                                   ; load next cmds char into s1
 27F  1D100                                COMPARE s1, 00                                   ; check for end of command
 280  32299                                JUMP Z, 299[cmd_find_call]
 281  1D1FF                                COMPARE s1, FF                                   ; check for no more commands
 282  322A6                                JUMP Z, 2A6[cmd_find_failed]
 283                                       ;; process next CLI_BUFFER char
 283  0B020                                FETCH s0, 20[CLI_BUFFER]                         ; get the end of buffer ptr
 284  1C200                                COMPARE s2, s0                                   ; check for overflow
 285  3E28D                                JUMP NC, 28D[cmd_find_next]
 286                                       ;; compare cmd/buffer chars
 286  0A020                                FETCH s0, (s2)                                   ; fetch the buffer's char
 287  1C010                                COMPARE s0, s1                                   ; compare it to the current cmd
 288  3628D                                JUMP NZ, 28D[cmd_find_next]                      ; move on to next command if not equal
 289  11201                                ADD s2, 01                                       ; move on to next char if equal
 28A  11A01                                ADD sA, 01
 28B  13B00                                ADDCY sB, 00
 28C  2227E                                JUMP 27E[cmd_find_loop]
 28D                        cmd_find_next: 
 28D                                       ;; find the next command
 28D  24BA0                                CALL@ (sB, sA)                                   ; load next cmds char into s1
 28E  1D1FF                                COMPARE s1, FF                                   ; check for no more commands
 28F  322A6                                JUMP Z, 2A6[cmd_find_failed]
 290  1D100                                COMPARE s1, 00                                   ; check for end of command
 291  32295                                JUMP Z, 295[cmd_find_next_reset]
 292  11A01                                ADD sA, 01
 293  13B00                                ADDCY sB, 00
 294  2228D                                JUMP 28D[cmd_find_next]
 295                  cmd_find_next_reset: 
 295                                       ;; move to the start of the next command
 295  11A03                                ADD sA, 03
 296  13B00                                ADDCY sB, 00
 297                                       ;; reset CLI_BUFFER pointer
 297  01200                                LOAD s2, 00[CLI_BUFFER_START]
 298  2227E                                JUMP 27E[cmd_find_loop]
 299                        cmd_find_call: 
 299                                       ;; call tokenizer
 299  202AA                                CALL 2AA[cmd_tokenize]
 29A  202F9                                CALL 2F9[cmd_parse_tokens]
 29B                                       ;; get command we are suppose to call
 29B  11A01                                ADD sA, 01
 29C  13B00                                ADDCY sB, 00
 29D  24BA0                                CALL@ (sB, sA)
 29E  00210                                LOAD s2, s1
 29F  11A01                                ADD sA, 01
 2A0  13B00                                ADDCY sB, 00
 2A1  24BA0                                CALL@ (sB, sA)
 2A2                                       ;; call the actual command
 2A2  24210                                CALL@ (s2, s1)
 2A3                                       ;; get ready for new user commands
 2A3  200A0                                CALL 0A0[soft_reset]
 2A4  20062                                CALL 062[util_print_prompt]
 2A5  25000                                RETURN 
 2A6                      cmd_find_failed: 
 2A6  200A0                                CALL 0A0[soft_reset]
 2A7  202E1                                CALL 2E1[cmd_invalid]
 2A8  20062                                CALL 062[util_print_prompt]
 2A9  25000                                RETURN 
 2AA                                       ;;; ============================================================================
 2AA                                       ;;; Search through string for 4 sequences of hex data
 2AA                                       ;; seaches through CLI_BUFFER using s2 to start
 2AA                                       ;; this will reset CLI_COUNT,CLI_WORD_*_POS,CLI_WORD_*_SIZE,CLI_WORD_*
 2AA                                       ;; uses s0,s1,s2,s3
 2AA                                       ;;; ============================================================================
 2AA                         cmd_tokenize: 
 2AA                                       ;; initialize CLI_COUNT to zero
 2AA  01000                                LOAD s0, 00
 2AB  2F023                                STORE s0, 23[CLI_COUNT]
 2AC                    cmd_tokenize_loop: 
 2AC                                       ;; search through the buffer for hex data
 2AC  0B120                                FETCH s1, 20[CLI_BUFFER]                         ; get end of valid buffer data
 2AD  1C210                                COMPARE s2, s1
 2AE  3E2D4                                JUMP NC, 2D4[cmd_tokenize_end]                   ; jump to the end if we run out of buffer
 2AF  0A020                                FETCH s0, (s2)                                   ; get next char
 2B0  11201                                ADD s2, 01                                       ; move forward in the buffer (for next time)
 2B1  20031                                CALL 031[util_char_to_nibble]                    ; check if currenc char is valid hex
 2B2  3E2AC                                JUMP NC, 2AC[cmd_tokenize_loop]                  ; non-ascii char, keep looking
 2B3  19201                                SUB s2, 01                                       ; move back in s2 since we want to be at the beginning of the hex string
 2B4                                       ;; found hex data. Update CLI_COUNT
 2B4  0B023                                FETCH s0, 23[CLI_COUNT]                          ; Get the number of words
 2B5  11001                                ADD s0, 01                                       ; Update the number of valid words
 2B6  1D005                                COMPARE s0, 05                                   ; check if we've reached our max
 2B7  322D4                                JUMP Z, 2D4[cmd_tokenize_end]                    ; end if we have
 2B8  2F023                                STORE s0, 23[CLI_COUNT]                          ; update CLI_COUNT
 2B9                                       ;; Start a new word by recording the position in CLI_WORD_*_POS
 2B9  01123                                LOAD s1, 23[CLI_COUNT]                           ; Load the CLI_COUNT address into s1
 2BA  10100                                ADD s1, s0                                       ; move forward in address by the current number of valid words (in s0)
 2BB  2E210                                STORE s2, (s1)                                   ; Write to this address the position of this word
 2BC  00320                                LOAD s3, s2                                      ; store the max position we an search to for valid hex
 2BD  11308                                ADD s3, 08                                       ; first assume that the hex string is 8 chars
 2BE  0B120                                FETCH s1, 20[CLI_BUFFER]                         ; now get the end of the buffer
 2BF  1C310                                COMPARE s3, s1                                   ; we have to make sure we don't walk off the buffer,
 2C0  3A2C2                                JUMP C, 2C2[cmd_tokenize_size]                   ; so compare the 8 char assumption to the buffer size
 2C1  00310                                LOAD s3, s1                                      ; and truncate if needed
 2C2                    cmd_tokenize_size: 
 2C2                                       ;; count number of hex digits (nibbles) in this word
 2C2  1C320                                COMPARE s3, s2                                   ; check if we've gone too far
 2C3  322C9                                JUMP Z, 2C9[cmd_tokenize_size_end]
 2C4  0A020                                FETCH s0, (s2)
 2C5  20031                                CALL 031[util_char_to_nibble]                    ; check if currenc char is valid hex
 2C6  3E2C9                                JUMP NC, 2C9[cmd_tokenize_size_end]              ; non-ascii char, go search for the next word
 2C7  11201                                ADD s2, 01                                       ; move forward in the string
 2C8  222C2                                JUMP 2C2[cmd_tokenize_size]
 2C9                cmd_tokenize_size_end: 
 2C9                                       ;; store the size of this word's data
 2C9  00320                                LOAD s3, s2                                      ; store our current position in s3
 2CA  0B123                                FETCH s1, 23[CLI_COUNT]                          ; Load the count number to let us fetch this word's start position
 2CB  11124                                ADD s1, 24[CLI_WORD_1_POS]                       ; Add the count to CLI_WORD_1_POS
 2CC  19101                                SUB s1, 01                                       ; move back one because count = 1 puts us in work 2 pos
 2CD  0A010                                FETCH s0, (s1)                                   ; fetch the start pointer for this word
 2CE  18300                                SUB s3, s0                                       ; computer the number of nibbles for this word
 2CF  0B023                                FETCH s0, 23[CLI_COUNT]                          ; computer the position of the current word's
 2D0  11028                                ADD s0, 28[CLI_WORD_1_SIZE]                      ; add the size 1 address
 2D1  19001                                SUB s0, 01                                       ; remove 1 because count starts at 1
 2D2  2E300                                STORE s3, (s0)                                   ; store the current word's size
 2D3  222AC                                JUMP 2AC[cmd_tokenize_loop]
 2D4                     cmd_tokenize_end: 
 2D4  25000                                RETURN 
 2D5                                       ;;; ============================================================================
 2D5                                       ;;; Prints "Bad command" to UART
 2D5                                       ;; uses s0-s1,sA-sB
 2D5                                       ;;; ============================================================================
 2D5                                       STRING BadCommand$, "Bad command"                ; string data
 2D5                       str_BadCommand: ; string function
 2D5  21142                                LOAD&RETURN s1, 42[BadCommand$:"B"]
 2D6  21161                                LOAD&RETURN s1, 61[BadCommand$:"a"]
 2D7  21164                                LOAD&RETURN s1, 64[BadCommand$:"d"]
 2D8  21120                                LOAD&RETURN s1, 20[BadCommand$:" "]
 2D9  21163                                LOAD&RETURN s1, 63[BadCommand$:"c"]
 2DA  2116F                                LOAD&RETURN s1, 6F[BadCommand$:"o"]
 2DB  2116D                                LOAD&RETURN s1, 6D[BadCommand$:"m"]
 2DC  2116D                                LOAD&RETURN s1, 6D[BadCommand$:"m"]
 2DD  21161                                LOAD&RETURN s1, 61[BadCommand$:"a"]
 2DE  2116E                                LOAD&RETURN s1, 6E[BadCommand$:"n"]
 2DF  21164                                LOAD&RETURN s1, 64[BadCommand$:"d"]
 2E0  21100                                LOAD&RETURN s1, 00
 2E1                          cmd_invalid: 
 2E1  01B02                                LOAD sB, 02[str_BadCommand'upper]                ; Load sB,sA to str function address
 2E2  01AD5                                LOAD sA, D5[str_BadCommand'lower]
 2E3  20066                                CALL 066[util_print_string]
 2E4  2005B                                CALL 05B[util_print_EOL]
 2E5  25000                                RETURN 
 2E6                                       ;;; ============================================================================
 2E6                                       ;;; Prints "Error s2" to UART
 2E6                                       ;; molests s0-s2,sA-sB
 2E6                                       ;;; EXTRA FUNCTIONALITY
 2E6                                       ;; if you want to quickly end a cmd_"subroutine" which has been
 2E6                                       ;; called using CALL, JUMP to this code instead.
 2E6                                       ;;; ============================================================================
 2E6                                       STRING Error$, "Error: "
 2E6                            str_Error: 
 2E6  21145                                LOAD&RETURN s1, 45[Error$:"E"]
 2E7  21172                                LOAD&RETURN s1, 72[Error$:"r"]
 2E8  21172                                LOAD&RETURN s1, 72[Error$:"r"]
 2E9  2116F                                LOAD&RETURN s1, 6F[Error$:"o"]
 2EA  21172                                LOAD&RETURN s1, 72[Error$:"r"]
 2EB  2113A                                LOAD&RETURN s1, 3A[Error$:":"]
 2EC  21120                                LOAD&RETURN s1, 20[Error$:" "]
 2ED  21100                                LOAD&RETURN s1, 00
 2EE                            cmd_error: 
 2EE  01B02                                LOAD sB, 02[str_Error'upper]                     ; Load sB,sA to str function address
 2EF  01AE6                                LOAD sA, E6[str_Error'lower]
 2F0  20066                                CALL 066[util_print_string]
 2F1                                       ;; convert s2 into hex and print it as an error number
 2F1  00020                                LOAD s0, s2
 2F2  20043                                CALL 043[util_byte_to_hex]
 2F3  20002                                CALL 002[uart_output_wait]
 2F4  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 2F5  20002                                CALL 002[uart_output_wait]
 2F6  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 2F7  2005B                                CALL 05B[util_print_EOL]
 2F8  25000                                RETURN 
 2F9                                       ;;; ============================================================================
 2F9                                       ;;; Parses the data at the tokens and puts them in CLI_WORD_*
 2F9                                       ;;; ============================================================================
 2F9                     cmd_parse_tokens: 
 2F9  01238                                LOAD s2, 38[CLI_WORD_4]
 2FA  11204                                ADD s2, 04                                       ;load end of parsed words pointer
 2FB  0112C                                LOAD s1, 2C[CLI_WORD_1]                          ;load start of parsed words pointer
 2FC                cmd_parse_tokens_zero: 
 2FC  01000                                LOAD s0, 00
 2FD  2E010                                STORE s0, (s1)                                   ;zero word data
 2FE  11101                                ADD s1, 01
 2FF  1C120                                COMPARE s1, s2                                   ;check that we are still below the end ptr
 300  3A2FC                                JUMP C, 2FC[cmd_parse_tokens_zero]
 301                                       ;; begin parsing
 301  01400                                LOAD s4, 00                                      ; store the offset to the current word
 302          cmd_parse_tokens_next_token: 
 302  0B023                                FETCH s0, 23[CLI_COUNT]                          ; store the number of words to parse
 303  1C400                                COMPARE s4, s0
 304  3E324                                JUMP NC, 324[cmd_parse_tokens_done]              ; jump to done when we are through the counts
 305                                       ;; find the start of the buffer
 305  01024                                LOAD s0, 24[CLI_WORD_1_POS]                      ; Get the position of the first pos
 306  10040                                ADD s0, s4                                       ; Move to the current pos
 307  0A500                                FETCH s5, (s0)                                   ; get the start of the word buffer
 308                                       ;; find the end of the buffer
 308  01128                                LOAD s1, 28[CLI_WORD_1_SIZE]
 309  10140                                ADD s1, s4                                       ; find size of this word in nibbles
 30A  0A610                                FETCH s6, (s1)
 30B  10650                                ADD s6, s5                                       ; move size past the start
 30C                                       ;; find the place we are storing the binary data
 30C  00740                                LOAD s7, s4                                      ; load the word number (-1)
 30D  14706                                SL0 s7
 30E  14706                                SL0 s7                                           ; multiply by 4 since thats how many bytes we allocate
 30F  1172C                                ADD s7, 2C[CLI_WORD_1]                           ; move to the byte after this word
 310                                       ;; update word index for next time
 310  11401                                ADD s4, 01
 311               cmd_parse_tokens_parse: 
 311  19602                                SUB s6, 02                                       ; move back a byte of data in the buffer
 312  3A302                                JUMP C, 302[cmd_parse_tokens_next_token]         ; catch bug for 1 char command
 313                                       ; the SUB 02 instruction would do a buffer underflow on this
 313  1C650                                COMPARE s6, s5                                   ; check that we have a full byte to parse
 314  3A31D                                JUMP C, 31D[cmd_parse_nibble]
 315                                       ;; parse a byte
 315  0A260                                FETCH s2, (s6)
 316  11601                                ADD s6, 01
 317  0A160                                FETCH s1, (s6)
 318  19601                                SUB s6, 01
 319  2001E                                CALL 01E[util_hex_to_byte]                       ; convert two hex digits to hex
 31A  2E070                                STORE s0, (s7)                                   ; store this byte
 31B  11701                                ADD s7, 01                                       ; move forward in data
 31C  22311                                JUMP 311[cmd_parse_tokens_parse]
 31D                     cmd_parse_nibble: 
 31D  11601                                ADD s6, 01
 31E  1C650                                COMPARE s6, s5
 31F  36302                                JUMP NZ, 302[cmd_parse_tokens_next_token]        ; there isn't even a nibble to parse
 320                                       ;; parse the nibble
 320  0A060                                FETCH s0, (s6)
 321  20031                                CALL 031[util_char_to_nibble]
 322  2E070                                STORE s0, (s7)
 323  22302                                JUMP 302[cmd_parse_tokens_next_token]
 324                cmd_parse_tokens_done: 
 324  25000                                RETURN 
 325                                       ;;; ============================================================================
 325                                       ;;; Main UART UI LOOP
 325                                       ;; uses s0-s1
 325                                       ;;; ============================================================================
 325                             cli_loop: 
 325  20006                                CALL 006[uart_input_wait]                        ; wait for input
 326  09001                                INPUT s0, 01[UART_INPUT]                         ; read new char from UART
 327  0B120                                FETCH s1, 20[CLI_BUFFER]                         ; get current write pointer
 328  11100                                ADD s1, 00[CLI_BUFFER_START]                     ; add CLI_BUFFER_START
 329  2E010                                STORE s0, (s1)                                   ; store input in CLI_BUFFER
 32A  0B120                                FETCH s1, 20[CLI_BUFFER]                         ; update CLI_BUFFER
 32B  11101                                ADD s1, 01
 32C  2F120                                STORE s1, 20[CLI_BUFFER]                         ;
 32D  1D120                                COMPARE s1, 20[CLI_BUFFER]                       ; check for CLI BUFFER overflow
 32E  3E33C                                JUMP NC, 33C[cli_overflow]
 32F  20344                                CALL 344[cli_process]                            ; process the new char
 330                                       ; return C=1 if a command
 330  3827B                                CALL C, 27B[cmd_find]                            ; process a new command
 331  22325                                JUMP 325[cli_loop]
 332                                       ;;; ============================================================================
 332                                       ;;; Error for UI overflow
 332                                       ;; uses s0-s1
 332                                       ;;; ============================================================================
 332                                       STRING overflow$, "Overflow!"
 332                         str_overflow: 
 332  2114F                                LOAD&RETURN s1, 4F[overflow$:"O"]
 333  21176                                LOAD&RETURN s1, 76[overflow$:"v"]
 334  21165                                LOAD&RETURN s1, 65[overflow$:"e"]
 335  21172                                LOAD&RETURN s1, 72[overflow$:"r"]
 336  21166                                LOAD&RETURN s1, 66[overflow$:"f"]
 337  2116C                                LOAD&RETURN s1, 6C[overflow$:"l"]
 338  2116F                                LOAD&RETURN s1, 6F[overflow$:"o"]
 339  21177                                LOAD&RETURN s1, 77[overflow$:"w"]
 33A  21121                                LOAD&RETURN s1, 21[overflow$:"!"]
 33B  21100                                LOAD&RETURN s1, 00
 33C                         cli_overflow: 
 33C  2005B                                CALL 05B[util_print_EOL]
 33D  01B03                                LOAD sB, 03[str_overflow'upper]
 33E  01A32                                LOAD sA, 32[str_overflow'lower]
 33F  20066                                CALL 066[util_print_string]
 340  2005B                                CALL 05B[util_print_EOL]
 341  200A0                                CALL 0A0[soft_reset]
 342  20062                                CALL 062[util_print_prompt]
 343  22325                                JUMP 325[cli_loop]
 344                                       ;;; ============================================================================
 344                                       ;;; parse the current text inputted by the user
 344                                       ;; check for special characters
 344                                       ;; echo back to use if needed
 344                                       ;; set C = 1 if the user pressed enter
 344                                       ;; uses s0-s1
 344                                       ;;; ============================================================================
 344                          cli_process: 
 344                                       ;; check last char for something special
 344  0B020                                FETCH s0, 20[CLI_BUFFER]
 345  19001                                SUB s0, 01
 346  0A100                                FETCH s1, (s0)                                   ; load the last ASCII into s0
 347  1D10D                                COMPARE s1, 0D                                   ; check for CR
 348  3235A                                JUMP Z, 35A[cli_process_cmd]
 349  1D10A                                COMPARE s1, 0A                                   ; check for LF
 34A  3235A                                JUMP Z, 35A[cli_process_cmd]
 34B  1D108                                COMPARE s1, 08                                   ; check for backspace
 34C  32361                                JUMP Z, 361[cli_process_bs]
 34D  1D120                                COMPARE s1, 20                                   ; check for other special char
 34E  3E355                                JUMP NC, 355[cli_process_text]                   ; jump for user text
 34F                                       ;; remove special char
 34F  0B020                                FETCH s0, 20[CLI_BUFFER]
 350  19001                                SUB s0, 01
 351  2F020                                STORE s0, 20[CLI_BUFFER]
 352  01000                                LOAD s0, 00
 353  1400C                                RR s0                                            ; set C to zero (no command)
 354  25000                                RETURN 
 355                     cli_process_text: 
 355  20002                                CALL 002[uart_output_wait]                       ; nothing special
 356  2D101                                OUTPUT s1, 01[UART_OUTPUT]                       ; echo char back to user
 357  01000                                LOAD s0, 00
 358  1400C                                RR s0                                            ; set C to zero (no command)
 359  25000                                RETURN 
 35A                      cli_process_cmd: 
 35A                                       ;; respond with EOL
 35A  2005B                                CALL 05B[util_print_EOL]
 35B                                       ;; remove the CR/LF character from memory
 35B  0B020                                FETCH s0, 20[CLI_BUFFER]
 35C  19001                                SUB s0, 01                                       ; remove CR/LF from memory
 35D  2F020                                STORE s0, 20[CLI_BUFFER]
 35E                                       ;; return with C = 1
 35E  01001                                LOAD s0, 01
 35F  1400C                                RR s0                                            ; set C to one
 360  25000                                RETURN 
 361                       cli_process_bs: 
 361  0B020                                FETCH s0, 20[CLI_BUFFER]                         ; check if there is anything to bs into
 362  19002                                SUB s0, 02                                       ; because we've already moved 1 ahead in CLI_BUFFER
 363  3A370                                JUMP C, 370[cli_process_bs_done]
 364                                       ;; update display
 364  20002                                CALL 002[uart_output_wait]
 365  01108                                LOAD s1, 08                                      ; backspace
 366  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 367  20002                                CALL 002[uart_output_wait]
 368  01120                                LOAD s1, 20[" "]                                 ; blank (clears bad char)
 369  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 36A  20002                                CALL 002[uart_output_wait]
 36B  01108                                LOAD s1, 08
 36C  2D101                                OUTPUT s1, 01[UART_OUTPUT]                       ; correctly sets next input char pos on screen
 36D                                       ;; we need to remove a total of two chars from buffer (bad + bs)
 36D                                       ;; remove one of them and leave one
 36D  0B020                                FETCH s0, 20[CLI_BUFFER]
 36E  19001                                SUB s0, 01
 36F  2F020                                STORE s0, 20[CLI_BUFFER]
 370                  cli_process_bs_done: 
 370                                       ;; We need to remove one character from buffer
 370  0B020                                FETCH s0, 20[CLI_BUFFER]
 371  19001                                SUB s0, 01
 372  2F020                                STORE s0, 20[CLI_BUFFER]
 373                                       ;; set C to zero since there was no command
 373  01000                                LOAD s0, 00
 374  1400C                                RR s0                                            ; set C to zero because there is no new command
 375  25000                                RETURN 



List of PSM files that have been assembled

Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cli.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\uart.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\utils.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\spi.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmd_names.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_C.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_D.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_F.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_G.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_H.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_M.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_P.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_R.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_S.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_T.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_V.psm



List of defined constants

 CONSTANT name               Value        Source PSM File

 timestamp_hours             14'd         
 timestamp_minutes           26'd         
 timestamp_seconds           30'd         
 datestamp_year              14'd         
 datestamp_month             2'd          
 datestamp_day               21'd         
 NUL                         00           
 BEL                         07           
 BS                          08           
 HT                          09           
 LF                          0A           
 VT                          0B           
 CR                          0D           
 ESC                         1B           
 DEL                         7F           
 DCS                         90           
 ST                          9C           
 CLI_BUFFER_START            00           cli.psm
 CLI_BUFFER                  20           cli.psm
 CLI_COUNT                   23           cli.psm
 CLI_WORD_1_POS              24           cli.psm
 CLI_WORD_2_POS              25           cli.psm
 CLI_WORD_3_POS              26           cli.psm
 CLI_WORD_4_POS              27           cli.psm
 CLI_WORD_1_SIZE             28           cli.psm
 CLI_WORD_2_SIZE             29           cli.psm
 CLI_WORD_3_SIZE             2A           cli.psm
 CLI_WORD_4_SIZE             2B           cli.psm
 CLI_WORD_1                  2C           cli.psm
 CLI_WORD_2                  30           cli.psm
 CLI_WORD_3                  34           cli.psm
 CLI_WORD_4                  38           cli.psm
 MEM_USER_1                  40           cli.psm
 MEM_USER_2                  80           cli.psm
 MEM_USER_3                  C0           cli.psm
 MEM_SIZE                    FF           cli.psm
 UI_VERSION                  01           cli.psm
 FIFO_data                   03           cli.psm
 FIFO_flags                  04           cli.psm
 UART_TX_RESET_PORT          00           cli.psm
 INITPORT                    00001000'b   cli.psm
 ONCEPORT                    00001001'b   cli.psm
 LED_PORT                    00000010'b   cli.psm
 SPI_PORT                    00000011'b   cli.psm
 PERIOD_PORT0                01000000'b   cli.psm
 PERIOD_PORT1                01000001'b   cli.psm
 PERIOD_PORT2                01000010'b   cli.psm
 PULSE_PERIOD_PORT0          01000100'b   cli.psm
 PULSE_PERIOD_PORT1          01000101'b   cli.psm
 PULSE_PERIOD_PORT2          01000110'b   cli.psm
 CTRL_port                   00100000'b   cli.psm
 C5_data                     11100000'b   cli.psm
 RESET_fifo_port             11100010'b   cli.psm
 spi_clk                     00000001'b   cli.psm
 spi_cs                      00000010'b   cli.psm
 spi_mosi                    10000000'b   cli.psm
 UART_STATUS                 00           uart.psm
 UART_INPUT                  01           uart.psm
 UART_OUTPUT                 01           uart.psm
 UART_STATUS_Tx_data_present 00000001'b   uart.psm
 UART_STATUS_Tx_half_full    00000010'b   uart.psm
 UART_STATUS_Tx_full         00000100'b   uart.psm
 UART_STATUS_Rx_data_present 00001000'b   uart.psm
 UART_STATUS_Rx_half_full    00010000'b   uart.psm
 UART_STATUS_Rx_full         00100000'b   uart.psm



No TABLEs defined



List of text strings

 STRING name       String             Source PSM File

 KCPSM6_version$   "v2.46"            
 datestamp$        "21 Feb 2014"      
 timestamp$        "14:26:30"         
 startup$          "CLI V:"           cli.psm
 BUFFER$           "Buffer: "         cmds_S.psm
 WORD_COUNT$       "Word count: "     cmds_S.psm
 WORD_SIZE$        "Word sizes:    "  cmds_S.psm
 WORD$             "Word "            cmds_S.psm
 ver$              "Version: "        cmds_V.psm
 multiarg$         "multiarg"         cmd_names.psm
 memdump$          "memdump"          cmd_names.psm
 reset$            "reset"            cmd_names.psm
 version$          "version"          cmd_names.psm
 sys$              "sys"              cmd_names.psm
 help$             "help"             cmd_names.psm
 dac$              "d"                cmd_names.psm
 channel$          "c"                cmd_names.psm
 fire$             "s"                cmd_names.psm
 rapid_on$         "n"                cmd_names.psm
 rapid_off$        "m"                cmd_names.psm
 cont_start$       "a"                cmd_names.psm
 cont_stop$        "z"                cmd_names.psm
 period$           "p"                cmd_names.psm
 pulse_period$     "t"                cmd_names.psm
 GEN_C5$           "CC"               cmd_names.psm
 GEN_D5$           "CD"               cmd_names.psm
 FIFO_flags$       "F"                cmd_names.psm
 FIFO_read$        "D"                cmd_names.psm
 FIFO_reset$       "R"                cmd_names.psm
 TDC_loopback$     "M"                cmd_names.psm
 BadCommand$       "Bad command"      cmds.psm
 Error$            "Error: "          cmds.psm
 overflow$         "Overflow!"        cli.psm



List of line labels

   Label                          Addr  Source PSM File

 * start                          000   cli.psm
   uart_output_wait               002   uart.psm
   uart_input_wait                006   uart.psm
 * uart_input_data                00C   uart.psm
 * uart_output_data               00F   uart.psm
 * uart_input_full                012   uart.psm
 * uart_output_full               015   uart.psm
 * uart_input_half_full           018   uart.psm
 * uart_output_half_full          01B   uart.psm
   util_hex_to_byte               01E   utils.psm
   util_hex_to_byte_error         02E   utils.psm
   util_char_to_nibble            031   utils.psm
   util_char_to_nibble_error      03F   utils.psm
   util_char_to_nibble_finish     042   utils.psm
   util_byte_to_hex               043   utils.psm
   util_byte_to_hex_next          04D   utils.psm
   util_byte_to_hex_end           054   utils.psm
   util_print_hex_byte            055   utils.psm
   util_print_EOL                 05B   utils.psm
   util_print_prompt              062   utils.psm
   util_print_string              066   utils.psm
   util_print_string_end          06E   utils.psm
   send_spi                       06F   spi.psm
   next_bit                       070   spi.psm
   clock_pulse                    07D   spi.psm
   sdelay                         085   spi.psm
   DLOOP                          087   spi.psm
   str_startup                    08A   cli.psm
   hard_reset                     091   cli.psm
   soft_reset                     0A0   cli.psm
   CMD_channel                    0A4   cmds_C.psm
   CMD_cont_start                 0B5   cmds_C.psm
   CMD_cont_stop                  0B8   cmds_C.psm
   CMD_dac                        0BB   cmds_D.psm
   CMD_fire                       0C1   cmds_F.psm
   CMD_FIFO_flags                 0C6   cmds_F.psm
   CMD_FIFO_read                  0CA   cmds_F.psm
 * FIFO_read_all                  0CD   cmds_F.psm
   FIFO_read_len                  0D0   cmds_F.psm
   do_D_init_read                 0D4   cmds_F.psm
   do_D_read                      0D7   cmds_F.psm
   do_D_empty                     0E4   cmds_F.psm
   CMD_FIFO_reset                 0E8   cmds_F.psm
   CMD_GEN_C5                     0EC   cmds_G.psm
   CMD_GEN_D5                     0F0   cmds_G.psm
   CMD_help                       0F3   cmds_H.psm
   CMD_help_loop                  0F5   cmds_H.psm
   CMD_help_eol                   0FF   cmds_H.psm
   CMD_help_end                   103   cmds_H.psm
   CMD_Mem_dump                   105   cmds_M.psm
   CMD_Mem_dump_loop              106   cmds_M.psm
   CMD_Mem_dump_line_loop         112   cmds_M.psm
   CMD_Mem_dump_end               121   cmds_M.psm
   CMD_multiarg                   123   cmds_M.psm
   CMD_multiarg_end               12D   cmds_M.psm
   CMD_period                     12E   cmds_P.psm
   CMD_pulse_period               13B   cmds_P.psm
   CMD_reset                      148   cmds_R.psm
   CMD_rapid_on                   14A   cmds_R.psm
   CMD_rapid_off                  14D   cmds_R.psm
   str_BUFFER                     150   cmds_S.psm
   str_WORD_COUNT                 159   cmds_S.psm
   str_WORD_SIZE                  166   cmds_S.psm
   str_WORD                       176   cmds_S.psm
   CMD_sys                        17C   cmds_S.psm
   CMD_sys_buffer                 181   cmds_S.psm
   CMD_sys_buffer_size            188   cmds_S.psm
 * CMD_sys_word_count             198   cmds_S.psm
   CMD_sys_word_pos               1A4   cmds_S.psm
   CMD_sys_word_size              1B6   cmds_S.psm
   CMD_sys_word_size_loop         1BC   cmds_S.psm
   CMD_sys_word                   1CB   cmds_S.psm
   CMD_sys_word_loop              1CE   cmds_S.psm
   CMD_sys_word_loop_print_loop   1E4   cmds_S.psm
   CMD_sys_word_end               1EE   cmds_S.psm
   CMD_TDC_loopback               1F0   cmds_T.psm
   str_ver                        1F3   cmds_V.psm
   CMD_version                    1FD   cmds_V.psm
   cmds                           208   cmd_names.psm
   cmd_find                       27B   cmds.psm
   cmd_find_loop                  27E   cmds.psm
   cmd_find_next                  28D   cmds.psm
   cmd_find_next_reset            295   cmds.psm
   cmd_find_call                  299   cmds.psm
   cmd_find_failed                2A6   cmds.psm
   cmd_tokenize                   2AA   cmds.psm
   cmd_tokenize_loop              2AC   cmds.psm
   cmd_tokenize_size              2C2   cmds.psm
   cmd_tokenize_size_end          2C9   cmds.psm
   cmd_tokenize_end               2D4   cmds.psm
   str_BadCommand                 2D5   cmds.psm
   cmd_invalid                    2E1   cmds.psm
   str_Error                      2E6   cmds.psm
 * cmd_error                      2EE   cmds.psm
   cmd_parse_tokens               2F9   cmds.psm
   cmd_parse_tokens_zero          2FC   cmds.psm
   cmd_parse_tokens_next_token    302   cmds.psm
   cmd_parse_tokens_parse         311   cmds.psm
   cmd_parse_nibble               31D   cmds.psm
   cmd_parse_tokens_done          324   cmds.psm
   cli_loop                       325   cli.psm
   str_overflow                   332   cli.psm
   cli_overflow                   33C   cli.psm
   cli_process                    344   cli.psm
   cli_process_text               355   cli.psm
   cli_process_cmd                35A   cli.psm
   cli_process_bs                 361   cli.psm
   cli_process_bs_done            370   cli.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            106
 STAR              -

 AND               6
 OR                4
 XOR               -

 ADD              58
 ADDCY             8
 SUB              21
 SUBCY             1

 TEST              8
 TESTCY            -
 COMPARE          36
 COMPARECY         -

 SL0              11
 SL1               -
 SLX               -
 SLA               1
 RL                -
 SR0               7
 SR1               -
 SRX               -
 SRA               -
 RR                4

 REGBANK           -

 INPUT            13
 OUTPUT           69
 OUTPUTK           2

 STORE            56
 FETCH            56

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             74
 JUMP@             -
 CALL            119
 CALL@             7
 RETURN           54
 LOAD&RETURN     206

 HWBUILD           -



End of KCPSM6 log file.
