KCPSM6 Assembler log file for program 'Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cli.psm'.
Generated by KCPSM6 version v2.46
Ken Chapman - Xilinx Ltd - 18th February 2013

Assembly datestamp: 28 Feb 2014
Assembly timestamp: 14:52:40

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 381 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 898
Memory locations available: 3198


Assembly listing

 Addr Code                                 Instruction

 000                                       ;;; ============================================================================
 000                                       ;;; EPP RAM test via UART UI
 000                                       ;; Dan Gastler
 000                                       ;; Boston University Electronics Design Facility
 000                                       ;; 2013-10-18 v1.0
 000                                       ;;; ============================================================================
 000                                       ;;; ============================================================================
 000                                       ;;; Register map
 000                                       ;;; ============================================================================
 000                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 000                                       ;;; | soft_reset | x  |    |
 000                                       ;;; | hard_reset | x  | x  | x  |    |    |    |    |    |    |    | x  |  x |
 000                                       ;;; | start  | x  | x  |
 000                                       ;;; | cli_loop   |
 000                                       ;;; | print_EOL  |
 000                                       ;;; ============================================================================
 000                                       ;;; Scratchpad memory map
 000                                       ;;; ============================================================================
 000                                       CONSTANT CLI_BUFFER_START, 00                    ; Start of the UART buffer
 000                                       CONSTANT CLI_BUFFER, 20                          ; Current write pointer in the CLI buffer
 000                                       CONSTANT CLI_COUNT, 23                           ; Number of valid parsed 16bit words on
 000                                       ; the command line
 000                                       CONSTANT CLI_WORD_1_POS, 24                      ; position in CLI_BUFFER where WORD1 starts
 000                                       CONSTANT CLI_WORD_2_POS, 25                      ; position in CLI_BUFFER where WORD2 starts
 000                                       CONSTANT CLI_WORD_3_POS, 26                      ; position in CLI_BUFFER where WORD3 starts
 000                                       CONSTANT CLI_WORD_4_POS, 27                      ; position in CLI_BUFFER where WORD4 starts
 000                                       CONSTANT CLI_WORD_1_SIZE, 28                     ; number of nibbles in this word
 000                                       CONSTANT CLI_WORD_2_SIZE, 29                     ; number of nibbles in this word
 000                                       CONSTANT CLI_WORD_3_SIZE, 2A                     ; number of nibbles in this word
 000                                       CONSTANT CLI_WORD_4_SIZE, 2B                     ; number of nibbles in this word
 000                                       CONSTANT CLI_WORD_1, 2C                          ; LSB of parsed word 1 (+ for MSB)
 000                                       CONSTANT CLI_WORD_2, 30                          ; LSB of parsed word 1
 000                                       CONSTANT CLI_WORD_3, 34                          ; LSB of parsed word 1
 000                                       CONSTANT CLI_WORD_4, 38                          ; LSB of parsed word 1
 000                                       CONSTANT MEM_USER_1, 40                          ; Start of User mem block 1
 000                                       CONSTANT MEM_USER_2, 80                          ; Start of User mem block 2
 000                                       CONSTANT MEM_USER_3, C0                          ; Start of User mem block 3
 000                                       CONSTANT MEM_SIZE, FF                            ; Size of our scratchpad memory
 000                                       ;;; ============================================================================
 000                                       ;;; Constants
 000                                       ;;; ============================================================================
 000                                       CONSTANT UI_VERSION, 01
 000                                       ;; input ports
 000                                       CONSTANT FIFO_data, 03
 000                                       CONSTANT FIFO_flags, 04
 000                                       ;; constant out ports
 000                                       CONSTANT UART_TX_RESET_PORT, 00
 000                                       ;; output ports
 000                                       CONSTANT LED_PORT, 00000010'b
 000                                       CONSTANT SPI_PORT, 00000011'b
 000                                       CONSTANT ONCEPORT, 00000100'b
 000                                       CONSTANT INITPORT, 00000101'b
 000                                       CONSTANT PERIOD_PORT2, 00000110'b
 000                                       CONSTANT PERIOD_PORT1, 00000111'b
 000                                       CONSTANT PERIOD_PORT0, 00001000'b
 000                                       CONSTANT PULSE_PERIOD_PORT2, 00001001'b
 000                                       CONSTANT PULSE_PERIOD_PORT1, 00001010'b
 000                                       CONSTANT PULSE_PERIOD_PORT0, 00001011'b
 000                                       CONSTANT CTRL_port, 00001100'b
 000                                       CONSTANT C5_data, 00100000'b
 000                                       CONSTANT RESET_fifo_port, 00100001'b
 000                                       ;; spi bits
 000                                       CONSTANT spi_clk, 00000001'b                     ;   spi_clk - bit0 (SPI_output_por0t)
 000                                       CONSTANT spi_cs, 00000010'b                      ;  spi_cs - bit1 (SPI_output_port)
 000                                       CONSTANT spi_mosi, 10000000'b                    ;  spi_mosi - bit7 (SPI_output_port)
 000                                       NAMEREG sC, SPI_HIGH
 000                                       NAMEREG sD, SPI_LOW
 000                                       ;;; ============================================================================
 000                                       ;;; START
 000                                       ;;; ============================================================================
 000                                start: 
 000  20091                                CALL 091[hard_reset]
 001  22331                                JUMP 331[cli_loop]
 002                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\uart.psm"["uart.psm"]
 002                                       ;;; ============================================================================
 002                                       ;;; Register map
 002                                       ;;; ============================================================================
 002                                       ;;; | name                  | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 002                                       ;;; | uart_output_wait      | x  |
 002                                       ;;; | uart_output_wait      | x  |
 002                                       ;;; | uart_input_data       | x  |
 002                                       ;;; | uart_output_data      | x  |
 002                                       ;;; | uart_input_full       | x  |
 002                                       ;;; | uart_output_full      | x  |
 002                                       ;;; | uart_input_half_full  | x  |
 002                                       ;;; | uart_output_half_full | x  |
 002                                       ;;; ============================================================================
 002                                       ;;; CONSTANTS
 002                                       ;;; ============================================================================
 002                                       ;;; UART ports
 002                                       CONSTANT UART_STATUS, 00                         ; Port with the RX/TX status bits
 002                                       CONSTANT UART_INPUT, 01                          ; 8bit reading port on microC
 002                                       CONSTANT UART_OUTPUT, 01                         ; 8bit writing port on microC
 002                                       ;;; uart status constants
 002                                       CONSTANT UART_STATUS_Tx_data_present, 00000001'b ; bit 0:  tx data present
 002                                       CONSTANT UART_STATUS_Tx_half_full, 00000010'b    ; bit 1:  tx half full (8 elements in FIFO)
 002                                       CONSTANT UART_STATUS_Tx_full, 00000100'b         ; bit 2:  tx full (16 elements in FIFO)
 002                                       CONSTANT UART_STATUS_Rx_data_present, 00001000'b ; bit 3:  rx data present
 002                                       CONSTANT UART_STATUS_Rx_half_full, 00010000'b    ; bit 4:  rx half full (8 elements in FIFO)
 002                                       CONSTANT UART_STATUS_Rx_full, 00100000'b         ; bit 5:  tx full (16 elements in FIFO)
 002                                       ;;; ============================================================================
 002                                       ;;; UART Tools
 002                                       ;;; ============================================================================
 002                                       ;;; wait for an available output space
 002                     uart_output_wait: 
 002  09000                                INPUT s0, 00[UART_STATUS]
 003  0D004                                TEST s0, 04[UART_STATUS_Tx_full]                 ; check if the tx FIFO is full
 004  31000                                RETURN Z
 005  22002                                JUMP 002[uart_output_wait]
 006                                       ;;; wait for UART input
 006                      uart_input_wait: 
 006  09000                                INPUT s0, 00[UART_STATUS]
 007  09F04                                INPUT sF, 04[FIFO_flags]
 008  2DF02                                OUTPUT sF, 02[LED_PORT]
 009  0D008                                TEST s0, 08[UART_STATUS_Rx_data_present]         ; check if the rx FIFO is full
 00A  39000                                RETURN C
 00B  22006                                JUMP 006[uart_input_wait]
 00C                                       ;;; Non-blocking tests
 00C                                       ;;; check if there is data to read, C=1 if true
 00C                      uart_input_data: 
 00C  09000                                INPUT s0, 00[UART_STATUS]
 00D  0D008                                TEST s0, 08[UART_STATUS_Rx_data_present]         ; test for input data
 00E  25000                                RETURN 
 00F                                       ;;; check if there is data in the FIFO to send, C=1 if true
 00F                     uart_output_data: 
 00F  09000                                INPUT s0, 00[UART_STATUS]
 010  0D001                                TEST s0, 01[UART_STATUS_Tx_data_present]         ; test for output data
 011  25000                                RETURN 
 012                                       ;;; check if the input buffer is full, C=1 if true
 012                      uart_input_full: 
 012  09000                                INPUT s0, 00[UART_STATUS]
 013  0D020                                TEST s0, 20[UART_STATUS_Rx_full]                 ; check if the rx FIFO is full
 014  25000                                RETURN 
 015                                       ;;; check if the output buffer is full, C=1 if true
 015                     uart_output_full: 
 015  09000                                INPUT s0, 00[UART_STATUS]
 016  0D004                                TEST s0, 04[UART_STATUS_Tx_full]                 ; check if the tx FIFO is full
 017  25000                                RETURN 
 018                                       ;;; check if the input buffer is half full, C=1 if true
 018                 uart_input_half_full: 
 018  09000                                INPUT s0, 00[UART_STATUS]
 019  0D010                                TEST s0, 10[UART_STATUS_Rx_half_full]            ; check if the rx FIFO is full
 01A  25000                                RETURN 
 01B                                       ;;; check if the output buffer is half full, C=1 if true
 01B                uart_output_half_full: 
 01B  09000                                INPUT s0, 00[UART_STATUS]
 01C  0D002                                TEST s0, 02[UART_STATUS_Tx_half_full]            ; check if the tx FIFO is full
 01D  25000                                RETURN 
 01E                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\utils.psm"["utils.psm"]
 01E                                       ;;; ============================================================================
 01E                                       ;;; Register map
 01E                                       ;;; ============================================================================
 01E                                       ;;; | name                     | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 01E                                       ;;; | util_hex_to_byte         | x  | x  | x  | x  |    |    |    |    |    |    |    |    |
 01E                                       ;;; | util_char_to_nibble      | x  |    |    |    |    |    |    |    |    |    |    |    |
 01E                                       ;;; | util_byte_to_hex         | x  | x  | x  |    |    |    |    |    |    |    |    |    |
 01E                                       ;;; | util_print_byte_to_hex   | x  | x  | x  |    |    |    |    |    |    |    |    |    |
 01E                                       ;;; | util_print_EOL           | x  | x  |    |    |    |    |    |    |    |    |    |    |
 01E                                       ;;; | util_print_prompt        | x  | x  |    |    |    |    |    |    |    |    |    |    |
 01E                                       ;;; | util_print_string        | x  | x  |    |    |    |    |    |    |    |    | x  | x  |
 01E                                       ;;;
 01E                                       ;;; ============================================================================
 01E                                       ;;; Convert two bytes of ascii to hex
 01E                                       ;; return byte in s0, C=1 for sucess, C=0 for failure
 01E                                       ;; load two ASCII characters in s2(MSB),s1(LSB)
 01E                                       ;; this uses s0-s3
 01E                                       ;;; ============================================================================
 01E                     util_hex_to_byte: 
 01E                                       ;; check and convert MSB
 01E  00020                                LOAD s0, s2                                      ; Call util_char_to_nibble to convert and check this is hex
 01F  20031                                CALL 031[util_char_to_nibble]
 020  3E02E                                JUMP NC, 02E[util_hex_to_byte_error]             ; jump to error if we failed
 021                                       ;; store result in the MSBs of s3
 021  00300                                LOAD s3, s0
 022  14306                                SL0 s3
 023  14306                                SL0 s3
 024  14306                                SL0 s3
 025  14306                                SL0 s3
 026                                       ;; check and convert LSB
 026  00010                                LOAD s0, s1
 027  20031                                CALL 031[util_char_to_nibble]
 028  3E02E                                JUMP NC, 02E[util_hex_to_byte_error]             ; jump to error if we failed
 029                                       ;; combine into s3,
 029  10300                                ADD s3, s0
 02A                                       ;; we converted sucessfully, so set C=1 and return s3 in s0
 02A  01001                                LOAD s0, 01
 02B  1400E                                SR0 s0
 02C  00030                                LOAD s0, s3
 02D  25000                                RETURN 
 02E               util_hex_to_byte_error: 
 02E  01000                                LOAD s0, 00                                      ; set s0 to zero and C=0
 02F  1400E                                SR0 s0
 030  25000                                RETURN 
 031                                       ;;; ============================================================================
 031                                       ;;; Check if char is a valid hex digit and convert it to a LSB nibble if it is
 031                                       ;; C=1 for valid, C=0 for invalid
 031                                       ;; load char from s0 (will be lost)
 031                                       ;; returns nibble in s0
 031                                       ;; uses s0
 031                                       ;;; ============================================================================
 031                  util_char_to_nibble: 
 031  19030                                SUB s0, 30                                       ; Drop s0 to 0-9 if the number was ascii 0-9
 032                                       ;; if some lower character, throw an error
 032  3A03F                                JUMP C, 03F[util_char_to_nibble_error]
 033  1D00A                                COMPARE s0, 0A                                   ; check for 0-9
 034                                       ;; jump to finish if nibble in range 0-9
 034  3A042                                JUMP C, 042[util_char_to_nibble_finish]
 035  19011                                SUB s0, 11                                       ; Move ASCII A to zero and see if we roll over
 036                                       ;; if some lower character, throw an error
 036  3A03F                                JUMP C, 03F[util_char_to_nibble_error]
 037  1100A                                ADD s0, 0A                                       ; add 10 to bring ascii A-F to dec 10-15
 038  1D010                                COMPARE s0, 10                                   ; compare to dec 16
 039                                       ;; Jump to finish if nibble in range A-F
 039  3A042                                JUMP C, 042[util_char_to_nibble_finish]
 03A  1902A                                SUB s0, 2A                                       ; bring ASCII a-f to dec 0-5
 03B                                       ;; if some lower character, throw an error
 03B  3A03F                                JUMP C, 03F[util_char_to_nibble_error]
 03C  1100A                                ADD s0, 0A                                       ; bring a-f to 10-15
 03D  1D010                                COMPARE s0, 10                                   ; compare to dec 16
 03E                                       ;; Jump to finish if nibble in range a-f
 03E  3A042                                JUMP C, 042[util_char_to_nibble_finish]
 03F                                       ;; other values are errors
 03F            util_char_to_nibble_error: 
 03F                                       ;; conversion failed, return s0=0 and C = 0
 03F  01000                                LOAD s0, 00
 040  1400E                                SR0 s0
 041  25000                                RETURN 
 042           util_char_to_nibble_finish: 
 042                                       ;; by my 1337 skillz (AKA: pure luck as I get to the part in the code),
 042                                       ;; C already is 1 and s0 is set... so return!
 042  25000                                RETURN 
 043                                       ;;; ============================================================================
 043                                       ;;; Convert one byte into two bytes of ASCII hex
 043                                       ;; loads s0
 043                                       ;; outputs s2,s1
 043                                       ;;; ============================================================================
 043                     util_byte_to_hex: 
 043                                       ;; convert MSNibble
 043  00200                                LOAD s2, s0
 044  1420E                                SR0 s2
 045  1420E                                SR0 s2
 046  1420E                                SR0 s2
 047  1420E                                SR0 s2
 048  11237                                ADD s2, 37                                       ; convert to A-F
 049  1D241                                COMPARE s2, 41
 04A                                       ;; If this wasn't a-F (ie 0-9) it will greater than 40
 04A  3E04D                                JUMP NC, 04D[util_byte_to_hex_next]
 04B  3204D                                JUMP Z, 04D[util_byte_to_hex_next]
 04C  19207                                SUB s2, 07                                       ; convert to 0-9
 04D                util_byte_to_hex_next: 
 04D  00100                                LOAD s1, s0
 04E  0310F                                AND s1, 0F                                       ; convert to LSNibble
 04F  11137                                ADD s1, 37                                       ; convert to A-F
 050  1D141                                COMPARE s1, 41                                   ; check if this is really A-F
 051  3E054                                JUMP NC, 054[util_byte_to_hex_end]
 052  32054                                JUMP Z, 054[util_byte_to_hex_end]
 053  19107                                SUB s1, 07                                       ; convert to 0-9
 054                 util_byte_to_hex_end: 
 054  25000                                RETURN 
 055                                       ;;; ============================================================================
 055                                       ;;; Convert one byte into two bytes of ASCII hex
 055                                       ;; loads s0
 055                                       ;; outputs s2,s1
 055                                       ;;; ============================================================================
 055                  util_print_hex_byte: 
 055  20043                                CALL 043[util_byte_to_hex]
 056  20002                                CALL 002[uart_output_wait]
 057  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 058  20002                                CALL 002[uart_output_wait]
 059  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 05A  25000                                RETURN 
 05B                                       ;;; ============================================================================
 05B                                       ;;; Write a new line on the UART screen
 05B                                       ;;; ============================================================================
 05B                       util_print_EOL: 
 05B  0110D                                LOAD s1, 0D                                      ; CR
 05C  20002                                CALL 002[uart_output_wait]
 05D  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 05E  0110A                                LOAD s1, 0A                                      ; LF
 05F  20002                                CALL 002[uart_output_wait]
 060  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 061  25000                                RETURN 
 062                                       ;;; ============================================================================
 062                                       ;;; Output the CLI prompt
 062                                       ;;; ============================================================================
 062                    util_print_prompt: 
 062  20002                                CALL 002[uart_output_wait]                       ; prompt
 063  0113E                                LOAD s1, 3E[">"]
 064  2D101                                OUTPUT s1, 01[UART_OUTPUT]                       ; echo
 065  25000                                RETURN 
 066                                       ;;; ============================================================================
 066                                       ;;; Prints a NULL terminated string @ sB,sA
 066                                       ;;  uses s1,sA,sB
 066                                       ;;; ============================================================================
 066                    util_print_string: 
 066  24BA0                                CALL@ (sB, sA)
 067  1D100                                COMPARE s1, 00
 068  3206E                                JUMP Z, 06E[util_print_string_end]               ; jump to finish if we get 00
 069  20002                                CALL 002[uart_output_wait]                       ; print currenc char to screen
 06A  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 06B  11A01                                ADD sA, 01                                       ; move forward in our string
 06C  13B00                                ADDCY sB, 00
 06D  22066                                JUMP 066[util_print_string]
 06E                util_print_string_end: 
 06E  25000                                RETURN 
 06F                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\spi.psm"["spi.psm"]
 06F                                       ;;; ============================================================================
 06F                                       ;;; Register map
 06F                                       ;;; ============================================================================
 06F                                       ;;; | name                | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 06F                                       ;;; | send_spi            |    |    |    |    |    |    | x  | x  | x  |    |    |    |
 06F  01710                      send_spi: LOAD s7, 10
 070  006C0                      next_bit: LOAD s6, sC[SPI_HIGH]
 071  03680                                AND s6, 80[spi_mosi]
 072  2D603                                OUTPUT s6, 03[SPI_PORT]
 073  14D06                                SL0 sD[SPI_LOW]
 074  14C00                                SLA sC[SPI_HIGH]
 075  2007D                                CALL 07D[clock_pulse]
 076  19701                                SUB s7, 01
 077  36070                                JUMP NZ, 070[next_bit]
 078  01602                                LOAD s6, 02[spi_cs]
 079  05601                                OR s6, 01[spi_clk]
 07A  2D603                                OUTPUT s6, 03[SPI_PORT]
 07B  20085                                CALL 085[sdelay]
 07C  25000                                RETURN 
 07D                          clock_pulse: 
 07D  05601                                OR s6, 01[spi_clk]
 07E  20085                                CALL 085[sdelay]
 07F  2D603                                OUTPUT s6, 03[SPI_PORT]
 080  036FE                                AND s6, FE[~spi_clk]
 081  20085                                CALL 085[sdelay]
 082  2D603                                OUTPUT s6, 03[SPI_PORT]
 083  20085                                CALL 085[sdelay]
 084  25000                                RETURN 
 085                               sdelay: 
 085  01840                                LOAD s8, 40
 086  22087                                JUMP 087[DLOOP]
 087                                DLOOP: 
 087  19801                                SUB s8, 01
 088  36087                                JUMP NZ, 087[DLOOP]
 089  25000                                RETURN 
 08A                                       ;;; ============================================================================
 08A                                       ;;; Reset the hardware and software to initial conditions
 08A                                       ;; uses s0 - s1
 08A                                       ;;; ============================================================================
 08A                                       STRING startup$, "CLI V:"
 08A                          str_startup: 
 08A  21143                                LOAD&RETURN s1, 43[startup$:"C"]
 08B  2114C                                LOAD&RETURN s1, 4C[startup$:"L"]
 08C  21149                                LOAD&RETURN s1, 49[startup$:"I"]
 08D  21120                                LOAD&RETURN s1, 20[startup$:" "]
 08E  21156                                LOAD&RETURN s1, 56[startup$:"V"]
 08F  2113A                                LOAD&RETURN s1, 3A[startup$:":"]
 090  21100                                LOAD&RETURN s1, 00
 091                           hard_reset: 
 091  01FFF                                LOAD sF, FF
 092  01EFF                                LOAD sE, FF
 093  01BFF                                LOAD sB, FF
 094                          start_delay: 
 094  19F01                                SUB sF, 01
 095  1BE00                                SUBCY sE, 00
 096  1BB00                                SUBCY sB, 00
 097  36094                                JUMP NZ, 094[start_delay]
 098  200A7                                CALL 0A7[soft_reset]
 099                                       ;; reset UART
 099  2B031                                OUTPUTK 03, 1[UART_OUTPUT]
 09A  2B001                                OUTPUTK 00, 1[UART_OUTPUT]
 09B                                       ;; print version
 09B  01B00                                LOAD sB, 00[str_startup'upper]
 09C  01A8A                                LOAD sA, 8A[str_startup'lower]
 09D  20066                                CALL 066[util_print_string]
 09E  01001                                LOAD s0, 01[UI_VERSION]
 09F  20043                                CALL 043[util_byte_to_hex]
 0A0  20002                                CALL 002[uart_output_wait]
 0A1  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 0A2  20002                                CALL 002[uart_output_wait]
 0A3  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 0A4  2005B                                CALL 05B[util_print_EOL]
 0A5  20062                                CALL 062[util_print_prompt]
 0A6  25000                                RETURN 
 0A7                                       ;;; ============================================================================
 0A7                                       ;;; Reset the software to initial conditions
 0A7                                       ;; uses s0
 0A7                                       ;;; ============================================================================
 0A7                           soft_reset: 
 0A7                                       ;; reset UART Buffer
 0A7  01000                                LOAD s0, 00
 0A8  2F020                                STORE s0, 20[CLI_BUFFER]
 0A9  2F023                                STORE s0, 23[CLI_COUNT]
 0AA  25000                                RETURN 
 0AB                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds.psm"["cmds.psm"]
 0AB                                       ;;; ============================================================================
 0AB                                       ;;; Register map
 0AB                                       ;;; ============================================================================
 0AB                                       ;;; | name                | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0AB                                       ;;; | cmd_find            | x  | x  | x  | x  |    |    |    |    |    |    | x  | x  |
 0AB                                       ;;; | cmd_tokenize        | x  | x  | x  | x  |    |    |    |    |    |    |    |    |
 0AB                                       ;;; | cmd_invalid   | x  | x  |    |    |    |    |    |    |    |    | x  | x  |
 0AB                                       ;;; | cmd_Error    | x  | x  | x  |    |    |    |    |    |    |    | x  | x  |
 0AB                                       ;;; | cmd_parse_tokens    | x  | x  | x  | x  | x  | x  | x  | x  |    |    |    |    |
 0AB                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmd_names.psm"["cmd_names.psm"]
 0AB                                       ;;; ============================================================================
 0AB                                       ;;; Register map
 0AB                                       ;;; ============================================================================
 0AB                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0AB                                       ;;; | cmds       |    | x  |    |    |    |    |    |    |    |    |    |    |
 0AB                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_C.psm"["cmds_C.psm"]
 0AB                                       ;;; ============================================================================
 0AB                                       ;;; Register map
 0AB                                       ;;; ============================================================================
 0AB                                       ;;; | name          | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0AB                                       ;;; | CMD_channel   | x  | x  |    |    | x  |    |    |    |    |    |    |    |
 0AB                                       ;;; | CMD_con_start | x  |    |    |    |    |    |    |    |    |    |    |    |
 0AB                                       ;;; | CMD_con_stop  | x  |    |    |    |    |    |    |    |    |    |    |    |
 0AB                          CMD_channel: 
 0AB  0B02C                                FETCH s0, 2C[CLI_WORD_1]
 0AC  14006                                SL0 s0
 0AD  14006                                SL0 s0                                           ;shift address into place
 0AE  00400                                LOAD s4, s0                                      ;store address
 0AF  05480                                OR s4, 80                                        ;lsb
 0B0  01130                                LOAD s1, 30[CLI_WORD_2]                          ;pointer
 0B1  0A010                                FETCH s0, (s1)                                   ;fetch lsb of channel period
 0B2  2C040                                OUTPUT s0, (s4)                                  ;output lsb
 0B3  11401                                ADD s4, 01                                       ;next byte of address
 0B4  11101                                ADD s1, 01                                       ;next byte of channel period
 0B5  0A010                                FETCH s0, (s1)
 0B6  2C040                                OUTPUT s0, (s4)                                  ;middle byte
 0B7  11401                                ADD s4, 01
 0B8  11101                                ADD s1, 01                                       ;msb, 0X
 0B9  0A010                                FETCH s0, (s1)
 0BA  2C040                                OUTPUT s0, (s4)                                  ;msb
 0BB  25000                                RETURN 
 0BC                       CMD_cont_start: 
 0BC  010FF                                LOAD s0, FF
 0BD  2D005                                OUTPUT s0, 05[INITPORT]
 0BE  25000                                RETURN 
 0BF                        CMD_cont_stop: 
 0BF  01000                                LOAD s0, 00
 0C0  2D005                                OUTPUT s0, 05[INITPORT]
 0C1  25000                                RETURN 
 0C2                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_D.psm"["cmds_D.psm"]
 0C2                                       ;;; ============================================================================
 0C2                                       ;;; Register map
 0C2                                       ;;; ============================================================================
 0C2                                       ;;; | name         | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0C2                                       ;;; | CMD_dac      | x  |    |    |    |    |    |    |    |    |    |    |    |
 0C2                              CMD_dac: 
 0C2  0102C                                LOAD s0, 2C[CLI_WORD_1]
 0C3  0AD00                                FETCH sD[SPI_LOW], (s0)
 0C4  11001                                ADD s0, 01
 0C5  0AC00                                FETCH sC[SPI_HIGH], (s0)
 0C6  2006F                                CALL 06F[send_spi]
 0C7  25000                                RETURN 
 0C8                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_F.psm"["cmds_F.psm"]
 0C8                                       ;;; ============================================================================
 0C8                                       ;;; Register map
 0C8                                       ;;; ============================================================================
 0C8                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0C8                                       ;;; | CMD_fire   | x  |    |    |    |    |    |    |    |    |    |    |    |
 0C8                             CMD_fire: 
 0C8  010FF                                LOAD s0, FF
 0C9  2D004                                OUTPUT s0, 04[ONCEPORT]
 0CA  01000                                LOAD s0, 00
 0CB  2D004                                OUTPUT s0, 04[ONCEPORT]
 0CC  25000                                RETURN 
 0CD                       CMD_FIFO_flags: 
 0CD  09004                                INPUT s0, 04[FIFO_flags]
 0CE  20055                                CALL 055[util_print_hex_byte]
 0CF  2005B                                CALL 05B[util_print_EOL]
 0D0  25000                                RETURN 
 0D1                        CMD_FIFO_read: 
 0D1  0B023                                FETCH s0, 23[CLI_COUNT]
 0D2  1D001                                COMPARE s0, 01
 0D3  320D7                                JUMP Z, 0D7[FIFO_read_len]
 0D4                        FIFO_read_all: 
 0D4  01700                                LOAD s7, 00                                      ;set count 0020 by default
 0D5  01620                                LOAD s6, 20
 0D6  220DB                                JUMP 0DB[do_D_init_read]
 0D7                        FIFO_read_len: 
 0D7  0102C                                LOAD s0, 2C[CLI_WORD_1]
 0D8  0A600                                FETCH s6, (s0)
 0D9  11001                                ADD s0, 01
 0DA  0A700                                FETCH s7, (s0)
 0DB                       do_D_init_read: 
 0DB  01801                                LOAD s8, 01                                      ;byte counter
 0DC  0103C                                LOAD s0, 3C                                      ; write K.28.1 word that is missed by the FIFO
 0DD  20055                                CALL 055[util_print_hex_byte]
 0DE                            do_D_read: 
 0DE  200F4                                CALL 0F4[Fdelay]
 0DF  09004                                INPUT s0, 04[FIFO_flags]
 0E0  03001                                AND s0, 01
 0E1  360EC                                JUMP NZ, 0EC[do_D_empty]                         ;go if empty
 0E2  09003                                INPUT s0, 03[FIFO_data]
 0E3  20055                                CALL 055[util_print_hex_byte]
 0E4  11801                                ADD s8, 01                                       ;increment byte coutner
 0E5  03803                                AND s8, 03                                       ;check module 4
 0E6  360DE                                JUMP NZ, 0DE[do_D_read]
 0E7  2005B                                CALL 05B[util_print_EOL]                         ;send CR after 4 bytes
 0E8  19601                                SUB s6, 01[1'd]                                  ;decrement word count
 0E9  1B700                                SUBCY s7, 00[0'd]
 0EA  360DE                                JUMP NZ, 0DE[do_D_read]
 0EB  25000                                RETURN 
 0EC                           do_D_empty: 
 0EC  01058                                LOAD s0, 58
 0ED  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 0EE  2005B                                CALL 05B[util_print_EOL]
 0EF  25000                                RETURN 
 0F0                       CMD_FIFO_reset: 
 0F0  2D021                                OUTPUT s0, 21[RESET_fifo_port]
 0F1  01F00                                LOAD sF, 00
 0F2  2DF02                                OUTPUT sF, 02[LED_PORT]
 0F3  25000                                RETURN 
 0F4                               Fdelay: 
 0F4  01FFF                                LOAD sF, FF
 0F5                               FDLOOP: 
 0F5  19F01                                SUB sF, 01
 0F6  360F5                                JUMP NZ, 0F5[FDLOOP]
 0F7  25000                                RETURN 
 0F8                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_G.psm"["cmds_G.psm"]
 0F8                                       ;;; ============================================================================
 0F8                                       ;;; Register map
 0F8                                       ;;; ============================================================================
 0F8                                       ;;; | name          | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0F8                                       ;;; | CMD_GEN_C5    | x  | x  |    |    |    |    |    |    |    |    |    |    |
 0F8                           CMD_GEN_C5: 
 0F8  0B02C                                FETCH s0, 2C[CLI_WORD_1]
 0F9  05010                                OR s0, 10                                        ;set bit 4 for C code
 0FA  2D020                                OUTPUT s0, 20[C5_data]
 0FB  25000                                RETURN 
 0FC                           CMD_GEN_D5: 
 0FC  0B02C                                FETCH s0, 2C[CLI_WORD_1]
 0FD  2D020                                OUTPUT s0, 20[C5_data]
 0FE  25000                                RETURN 
 0FF                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_H.psm"["cmds_H.psm"]
 0FF                                       ;;; ============================================================================
 0FF                                       ;;; Register map
 0FF                                       ;;; ============================================================================
 0FF                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0FF                                       ;;; | CMD_help   | x  | x  |    |    |    |    |    |    |    |    | x  |  x |
 0FF                                       ;;; ============================================================================
 0FF                                       ;;; Print Help functions
 0FF                                       ;; uses sA-sB, s1
 0FF                                       ;;; ============================================================================
 0FF                             CMD_help: 
 0FF  01B02                                LOAD sB, 02[cmds'upper]
 100  01A14                                LOAD sA, 14[cmds'lower]
 101                        CMD_help_loop: 
 101                                       ;; loop over commands
 101  24BA0                                CALL@ (sB, sA)                                   ; load next CMDs char into s1
 102  1D100                                COMPARE s1, 00                                   ; check for end of command
 103  3210B                                JUMP Z, 10B[CMD_help_eol]
 104  1D1FF                                COMPARE s1, FF                                   ; check for no more commands
 105  3210F                                JUMP Z, 10F[CMD_help_end]
 106  20002                                CALL 002[uart_output_wait]
 107  2D101                                OUTPUT s1, 01[UART_OUTPUT]                       ; print char
 108  11A01                                ADD sA, 01                                       ; move forward
 109  13B00                                ADDCY sB, 00
 10A  22101                                JUMP 101[CMD_help_loop]
 10B                         CMD_help_eol: 
 10B  2005B                                CALL 05B[util_print_EOL]                         ; print EOL
 10C  11A03                                ADD sA, 03                                       ; move forwardpast the function address
 10D  13B00                                ADDCY sB, 00
 10E  22101                                JUMP 101[CMD_help_loop]
 10F                         CMD_help_end: 
 10F  2005B                                CALL 05B[util_print_EOL]
 110  25000                                RETURN 
 111                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_M.psm"["cmds_M.psm"]
 111                                       ;;; ============================================================================
 111                                       ;;; Register map
 111                                       ;;; ============================================================================
 111                                       ;;; | name         | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 111                                       ;;; | CMD_Mem_dump | x  | x  | x  | x  |    |    |    |    |    |    | x  |  x |
 111                                       ;;; | CMD_multiarg | x  | x  | x  | x  | x  | x  | x  |    |    |    | x  |  x |
 111                                       ;;; DUMP data to user
 111                                       ;; 1) write size of data in memory
 111                                       ;; 2) Write data
 111                                       ;; 3) Write CMD_DUMP
 111                                       ;;; ============================================================================
 111                         CMD_Mem_dump: 
 111  01300                                LOAD s3, 00                                      ; initialize read pointer
 112                    CMD_Mem_dump_loop: 
 112                                       ;; print offset
 112  00030                                LOAD s0, s3
 113  20043                                CALL 043[util_byte_to_hex]
 114  20002                                CALL 002[uart_output_wait]
 115  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 116  20002                                CALL 002[uart_output_wait]
 117  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 118                                       ;; print ": "
 118  20002                                CALL 002[uart_output_wait]
 119  0103A                                LOAD s0, 3A[":"]
 11A  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 11B  20002                                CALL 002[uart_output_wait]
 11C  01020                                LOAD s0, 20[" "]
 11D  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 11E                                       ;; print 4 bytes of data
 11E               CMD_Mem_dump_line_loop: 
 11E  0A030                                FETCH s0, (s3)                                   ; fetch data
 11F  20043                                CALL 043[util_byte_to_hex]
 120  20002                                CALL 002[uart_output_wait]
 121  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 122  20002                                CALL 002[uart_output_wait]
 123  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 124                                       ;; check for end of the buffer
 124  1D3FF                                COMPARE s3, FF[MEM_SIZE]                         ; see if we are past valid memory
 125  3212D                                JUMP Z, 12D[CMD_Mem_dump_end]
 126                                       ;; backup last printed pointer
 126  00030                                LOAD s0, s3
 127  11301                                ADD s3, 01                                       ;move forward in pointer
 128                                       ;; determine if we are at the 4 byte line boundary
 128  03003                                AND s0, 03
 129  1D003                                COMPARE s0, 03
 12A  3611E                                JUMP NZ, 11E[CMD_Mem_dump_line_loop]
 12B                                       ;; print EOL after 4 bytes
 12B  2005B                                CALL 05B[util_print_EOL]
 12C  22112                                JUMP 112[CMD_Mem_dump_loop]
 12D                     CMD_Mem_dump_end: 
 12D  2005B                                CALL 05B[util_print_EOL]
 12E  25000                                RETURN 
 12F                         CMD_multiarg: 
 12F  20188                                CALL 188[CMD_sys]
 130  0B023                                FETCH s0, 23[CLI_COUNT]                          ; load the already parsed commands
 131  1D004                                COMPARE s0, 04                                   ; jump to the end if we have fewer than 4 args
 132  3A139                                JUMP C, 139[CMD_multiarg_end]
 133                                       ;; reparse the reset of the args
 133                                       ;; get CMD4's postions
 133  0B227                                FETCH s2, 27[CLI_WORD_4_POS]
 134                                       ;; get CMD4's size
 134  0B12B                                FETCH s1, 2B[CLI_WORD_4_SIZE]
 135  10210                                ADD s2, s1
 136                                       ;; computer new end pos
 136  202B6                                CALL 2B6[cmd_tokenize]
 137  20305                                CALL 305[cmd_parse_tokens]
 138  20188                                CALL 188[CMD_sys]
 139                     CMD_multiarg_end: 
 139  25000                                RETURN 
 13A                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_P.psm"["cmds_P.psm"]
 13A                                       ;;; ============================================================================
 13A                                       ;;; Register map
 13A                                       ;;; ============================================================================
 13A                                       ;;; | name             | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 13A                                       ;;; | CMD_period       | x  | x  |    |    | x  |    |    |    |    |    |    |    |
 13A                                       ;;; | CMD_pulse_period | x  | x  |    |    | x  |    |    |    |    |    |    |    |
 13A                           CMD_period: 
 13A  01440                                LOAD s4, 40                                      ;store address
 13B  0112C                                LOAD s1, 2C[CLI_WORD_1]                          ;pointer
 13C  0A010                                FETCH s0, (s1)                                   ;fetch lsb of channel period
 13D  2C040                                OUTPUT s0, (s4)                                  ;output lsb
 13E  11401                                ADD s4, 01                                       ;next byte of address
 13F  11101                                ADD s1, 01                                       ;next byte of channel period
 140  0A010                                FETCH s0, (s1)
 141  2C040                                OUTPUT s0, (s4)                                  ;middle byte
 142  11401                                ADD s4, 01
 143  11101                                ADD s1, 01                                       ;msb
 144  0A010                                FETCH s0, (s1)
 145  2C040                                OUTPUT s0, (s4)                                  ;msb
 146  25000                                RETURN 
 147                     CMD_pulse_period: 
 147  01444                                LOAD s4, 44                                      ;store address
 148  0112C                                LOAD s1, 2C[CLI_WORD_1]                          ;pointer
 149  0A010                                FETCH s0, (s1)                                   ;fetch lsb of channel period
 14A  2C040                                OUTPUT s0, (s4)                                  ;output lsb
 14B  11401                                ADD s4, 01                                       ;next byte of address
 14C  11101                                ADD s1, 01                                       ;next byte of channel period
 14D  0A010                                FETCH s0, (s1)
 14E  2C040                                OUTPUT s0, (s4)                                  ;middle byte
 14F  11401                                ADD s4, 01
 150  11101                                ADD s1, 01                                       ;msb
 151  0A010                                FETCH s0, (s1)
 152  2C040                                OUTPUT s0, (s4)                                  ;msb
 153  25000                                RETURN 
 154                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_R.psm"["cmds_R.psm"]
 154                                       ;;; ============================================================================
 154                                       ;;; Register map
 154                                       ;;; ============================================================================
 154                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 154                                       ;;; | CMD_reset  | x  | x  | x  |    |    |    |    |    |    |    | x  |  x |
 154                                       ;;; ============================================================================
 154                                       ;;; Reset UI
 154                                       ;;; ============================================================================
 154                            CMD_reset: 
 154  20091                                CALL 091[hard_reset]
 155  25000                                RETURN 
 156                         CMD_rapid_on: 
 156  010FF                                LOAD s0, FF
 157  2D004                                OUTPUT s0, 04[ONCEPORT]
 158  25000                                RETURN 
 159                        CMD_rapid_off: 
 159  01000                                LOAD s0, 00
 15A  2D004                                OUTPUT s0, 04[ONCEPORT]
 15B  25000                                RETURN 
 15C                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_S.psm"["cmds_S.psm"]
 15C                                       ;;; ============================================================================
 15C                                       ;;; Register map
 15C                                       ;;; ============================================================================
 15C                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 15C                                       ;;; | CMD_sys    | x  | x  | x  | x  | x  | x  | x  |    |    |    | x  |  x |
 15C                                       STRING BUFFER$, "Buffer: "
 15C                                       STRING WORD_COUNT$, "Word count: "
 15C                                       STRING WORD_SIZE$, "Word sizes:    "
 15C                                       STRING WORD$, "Word "
 15C                           str_BUFFER: 
 15C  21142                                LOAD&RETURN s1, 42[BUFFER$:"B"]
 15D  21175                                LOAD&RETURN s1, 75[BUFFER$:"u"]
 15E  21166                                LOAD&RETURN s1, 66[BUFFER$:"f"]
 15F  21166                                LOAD&RETURN s1, 66[BUFFER$:"f"]
 160  21165                                LOAD&RETURN s1, 65[BUFFER$:"e"]
 161  21172                                LOAD&RETURN s1, 72[BUFFER$:"r"]
 162  2113A                                LOAD&RETURN s1, 3A[BUFFER$:":"]
 163  21120                                LOAD&RETURN s1, 20[BUFFER$:" "]
 164  21100                                LOAD&RETURN s1, 00
 165                       str_WORD_COUNT: 
 165  21157                                LOAD&RETURN s1, 57[WORD_COUNT$:"W"]
 166  2116F                                LOAD&RETURN s1, 6F[WORD_COUNT$:"o"]
 167  21172                                LOAD&RETURN s1, 72[WORD_COUNT$:"r"]
 168  21164                                LOAD&RETURN s1, 64[WORD_COUNT$:"d"]
 169  21120                                LOAD&RETURN s1, 20[WORD_COUNT$:" "]
 16A  21163                                LOAD&RETURN s1, 63[WORD_COUNT$:"c"]
 16B  2116F                                LOAD&RETURN s1, 6F[WORD_COUNT$:"o"]
 16C  21175                                LOAD&RETURN s1, 75[WORD_COUNT$:"u"]
 16D  2116E                                LOAD&RETURN s1, 6E[WORD_COUNT$:"n"]
 16E  21174                                LOAD&RETURN s1, 74[WORD_COUNT$:"t"]
 16F  2113A                                LOAD&RETURN s1, 3A[WORD_COUNT$:":"]
 170  21120                                LOAD&RETURN s1, 20[WORD_COUNT$:" "]
 171  21100                                LOAD&RETURN s1, 00
 172                        str_WORD_SIZE: 
 172  21157                                LOAD&RETURN s1, 57[WORD_SIZE$:"W"]
 173  2116F                                LOAD&RETURN s1, 6F[WORD_SIZE$:"o"]
 174  21172                                LOAD&RETURN s1, 72[WORD_SIZE$:"r"]
 175  21164                                LOAD&RETURN s1, 64[WORD_SIZE$:"d"]
 176  21120                                LOAD&RETURN s1, 20[WORD_SIZE$:" "]
 177  21173                                LOAD&RETURN s1, 73[WORD_SIZE$:"s"]
 178  21169                                LOAD&RETURN s1, 69[WORD_SIZE$:"i"]
 179  2117A                                LOAD&RETURN s1, 7A[WORD_SIZE$:"z"]
 17A  21165                                LOAD&RETURN s1, 65[WORD_SIZE$:"e"]
 17B  21173                                LOAD&RETURN s1, 73[WORD_SIZE$:"s"]
 17C  2113A                                LOAD&RETURN s1, 3A[WORD_SIZE$:":"]
 17D  21120                                LOAD&RETURN s1, 20[WORD_SIZE$:" "]
 17E  21120                                LOAD&RETURN s1, 20[WORD_SIZE$:" "]
 17F  21120                                LOAD&RETURN s1, 20[WORD_SIZE$:" "]
 180  21120                                LOAD&RETURN s1, 20[WORD_SIZE$:" "]
 181  21100                                LOAD&RETURN s1, 00
 182                             str_WORD: 
 182  21157                                LOAD&RETURN s1, 57[WORD$:"W"]
 183  2116F                                LOAD&RETURN s1, 6F[WORD$:"o"]
 184  21172                                LOAD&RETURN s1, 72[WORD$:"r"]
 185  21164                                LOAD&RETURN s1, 64[WORD$:"d"]
 186  21120                                LOAD&RETURN s1, 20[WORD$:" "]
 187  21100                                LOAD&RETURN s1, 00
 188                                       ;;; ============================================================================
 188                                       ;;; Prints system area of scratchpad to the screen for debugging
 188                                       ;; uses sA,sB,s0,s1,s2,s3,s4,s5,s6
 188                                       ;;; ============================================================================
 188                              CMD_sys: 
 188                                       ;; print CLI buffer
 188  01B01                                LOAD sB, 01[str_BUFFER'upper]
 189  01A5C                                LOAD sA, 5C[str_BUFFER'lower]
 18A  20066                                CALL 066[util_print_string]
 18B                                       ;; load values from buffer to print
 18B  01100                                LOAD s1, 00[CLI_BUFFER_START]
 18C  0B220                                FETCH s2, 20[CLI_BUFFER]
 18D                       CMD_sys_buffer: 
 18D  1C120                                COMPARE s1, s2
 18E  3E194                                JUMP NC, 194[CMD_sys_buffer_size]                ;when we are done with the buffer, jump to word count
 18F  20002                                CALL 002[uart_output_wait]
 190  0A010                                FETCH s0, (s1)
 191  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 192  11101                                ADD s1, 01
 193  2218D                                JUMP 18D[CMD_sys_buffer]
 194                  CMD_sys_buffer_size: 
 194  20002                                CALL 002[uart_output_wait]
 195  01020                                LOAD s0, 20[" "]
 196  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 197  20002                                CALL 002[uart_output_wait]
 198  01028                                LOAD s0, 28["("]
 199  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 19A  00020                                LOAD s0, s2
 19B  20043                                CALL 043[util_byte_to_hex]
 19C  20002                                CALL 002[uart_output_wait]
 19D  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 19E  20002                                CALL 002[uart_output_wait]
 19F  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 1A0  20002                                CALL 002[uart_output_wait]
 1A1  01029                                LOAD s0, 29[")"]
 1A2  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 1A3  2005B                                CALL 05B[util_print_EOL]
 1A4                   CMD_sys_word_count: 
 1A4                                       ;; print word count
 1A4  01B01                                LOAD sB, 01[str_WORD_COUNT'upper]
 1A5  01A65                                LOAD sA, 65[str_WORD_COUNT'lower]
 1A6  20066                                CALL 066[util_print_string]
 1A7  20002                                CALL 002[uart_output_wait]
 1A8  0B023                                FETCH s0, 23[CLI_COUNT]
 1A9  20043                                CALL 043[util_byte_to_hex]
 1AA  20002                                CALL 002[uart_output_wait]
 1AB  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 1AC  20002                                CALL 002[uart_output_wait]
 1AD  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 1AE  0B423                                FETCH s4, 23[CLI_COUNT]
 1AF  01300                                LOAD s3, 00
 1B0                     CMD_sys_word_pos: 
 1B0  1C340                                COMPARE s3, s4
 1B1  3E1C2                                JUMP NC, 1C2[CMD_sys_word_size]
 1B2  20002                                CALL 002[uart_output_wait]
 1B3  01020                                LOAD s0, 20[" "]
 1B4  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 1B5  20002                                CALL 002[uart_output_wait]
 1B6  01040                                LOAD s0, 40["@"]
 1B7  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 1B8  01124                                LOAD s1, 24[CLI_WORD_1_POS]
 1B9  10130                                ADD s1, s3
 1BA  0A010                                FETCH s0, (s1)
 1BB  20043                                CALL 043[util_byte_to_hex]
 1BC  20002                                CALL 002[uart_output_wait]
 1BD  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 1BE  20002                                CALL 002[uart_output_wait]
 1BF  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 1C0  11301                                ADD s3, 01
 1C1  221B0                                JUMP 1B0[CMD_sys_word_pos]
 1C2                    CMD_sys_word_size: 
 1C2  2005B                                CALL 05B[util_print_EOL]
 1C3                                       ;; print word size
 1C3  01B01                                LOAD sB, 01[str_WORD_SIZE'upper]
 1C4  01A72                                LOAD sA, 72[str_WORD_SIZE'lower]
 1C5  20066                                CALL 066[util_print_string]
 1C6  0B423                                FETCH s4, 23[CLI_COUNT]
 1C7  01300                                LOAD s3, 00
 1C8               CMD_sys_word_size_loop: 
 1C8  1C340                                COMPARE s3, s4
 1C9  3E1D7                                JUMP NC, 1D7[CMD_sys_word]
 1CA  20002                                CALL 002[uart_output_wait]
 1CB  01020                                LOAD s0, 20[" "]
 1CC  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 1CD  01128                                LOAD s1, 28[CLI_WORD_1_SIZE]
 1CE  10130                                ADD s1, s3
 1CF  0A010                                FETCH s0, (s1)
 1D0  20043                                CALL 043[util_byte_to_hex]
 1D1  20002                                CALL 002[uart_output_wait]
 1D2  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 1D3  20002                                CALL 002[uart_output_wait]
 1D4  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 1D5  11301                                ADD s3, 01
 1D6  221C8                                JUMP 1C8[CMD_sys_word_size_loop]
 1D7                         CMD_sys_word: 
 1D7  2005B                                CALL 05B[util_print_EOL]
 1D8  0B423                                FETCH s4, 23[CLI_COUNT]
 1D9  01300                                LOAD s3, 00
 1DA                    CMD_sys_word_loop: 
 1DA  1C340                                COMPARE s3, s4
 1DB  3E1FA                                JUMP NC, 1FA[CMD_sys_word_end]
 1DC                                       ;; print word size
 1DC  2005B                                CALL 05B[util_print_EOL]
 1DD  01B01                                LOAD sB, 01[str_WORD'upper]
 1DE  01A82                                LOAD sA, 82[str_WORD'lower]
 1DF  20066                                CALL 066[util_print_string]
 1E0  00030                                LOAD s0, s3
 1E1  20043                                CALL 043[util_byte_to_hex]
 1E2  20002                                CALL 002[uart_output_wait]
 1E3  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 1E4  20002                                CALL 002[uart_output_wait]
 1E5  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 1E6  20002                                CALL 002[uart_output_wait]
 1E7  01020                                LOAD s0, 20[" "]
 1E8  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 1E9                                       ;; go to the offset for this word
 1E9  00530                                LOAD s5, s3
 1EA  11301                                ADD s3, 01
 1EB  14506                                SL0 s5
 1EC  14506                                SL0 s5
 1ED  1152C                                ADD s5, 2C[CLI_WORD_1]
 1EE  00650                                LOAD s6, s5
 1EF  11603                                ADD s6, 03
 1F0         CMD_sys_word_loop_print_loop: 
 1F0  1C650                                COMPARE s6, s5
 1F1  3A1DA                                JUMP C, 1DA[CMD_sys_word_loop]
 1F2  0A060                                FETCH s0, (s6)
 1F3  20043                                CALL 043[util_byte_to_hex]
 1F4  20002                                CALL 002[uart_output_wait]
 1F5  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 1F6  20002                                CALL 002[uart_output_wait]
 1F7  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 1F8  19601                                SUB s6, 01
 1F9  221F0                                JUMP 1F0[CMD_sys_word_loop_print_loop]
 1FA                     CMD_sys_word_end: 
 1FA  2005B                                CALL 05B[util_print_EOL]
 1FB  25000                                RETURN 
 1FC                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_T.psm"["cmds_T.psm"]
 1FC                                       ;;; ============================================================================
 1FC                                       ;;; Register map
 1FC                                       ;;; ============================================================================
 1FC                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 1FC                                       ;;; | cmds       |    | x  |    |    |    |    |    |    |    |    |    |    |
 1FC                     CMD_TDC_loopback: 
 1FC  0B02C                                FETCH s0, 2C[CLI_WORD_1]
 1FD  2D00C                                OUTPUT s0, 0C[CTRL_port]
 1FE  25000                                RETURN 
 1FF                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_V.psm"["cmds_V.psm"]
 1FF                                       ;;; ============================================================================
 1FF                                       ;;; Register map
 1FF                                       ;;; ============================================================================
 1FF                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 1FF                                       ;;; | hard_reset | x  | x  | x  |    |    |    |    |    |    |    | x  |  x |
 1FF                                       ;;; ============================================================================
 1FF                                       ;;; Prints "Ver: #" to UART
 1FF                                       ;; molests s0-s2
 1FF                                       ;;; ============================================================================
 1FF                                       STRING ver$, "Version: "
 1FF                              str_ver: 
 1FF  21156                                LOAD&RETURN s1, 56[ver$:"V"]
 200  21165                                LOAD&RETURN s1, 65[ver$:"e"]
 201  21172                                LOAD&RETURN s1, 72[ver$:"r"]
 202  21173                                LOAD&RETURN s1, 73[ver$:"s"]
 203  21169                                LOAD&RETURN s1, 69[ver$:"i"]
 204  2116F                                LOAD&RETURN s1, 6F[ver$:"o"]
 205  2116E                                LOAD&RETURN s1, 6E[ver$:"n"]
 206  2113A                                LOAD&RETURN s1, 3A[ver$:":"]
 207  21120                                LOAD&RETURN s1, 20[ver$:" "]
 208  21100                                LOAD&RETURN s1, 00
 209                          CMD_version: 
 209  01B01                                LOAD sB, 01[str_ver'upper]
 20A  01AFF                                LOAD sA, FF[str_ver'lower]
 20B  20066                                CALL 066[util_print_string]
 20C  01001                                LOAD s0, 01[UI_VERSION]
 20D  20043                                CALL 043[util_byte_to_hex]
 20E  20002                                CALL 002[uart_output_wait]
 20F  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 210  20002                                CALL 002[uart_output_wait]
 211  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 212  2005B                                CALL 05B[util_print_EOL]
 213  25000                                RETURN 
 214                                       STRING multiarg$, "multiarg"
 214                                       STRING memdump$, "memdump"
 214                                       STRING reset$, "reset"
 214                                       STRING version$, "version"
 214                                       STRING sys$, "sys"
 214                                       STRING help$, "help"
 214                                       STRING dac$, "d"
 214                                       STRING channel$, "c"
 214                                       STRING fire$, "s"
 214                                       STRING rapid_on$, "n"
 214                                       STRING rapid_off$, "m"
 214                                       ;; STRING pulse_help msg$, "h"
 214                                       STRING cont_start$, "a"
 214                                       STRING cont_stop$, "z"
 214                                       STRING period$, "p"
 214                                       STRING pulse_period$, "t"
 214                                       STRING GEN_C5$, "CC"
 214                                       STRING GEN_D5$, "CD"
 214                                       STRING FIFO_flags$, "F"
 214                                       STRING FIFO_read$, "D"
 214                                       STRING FIFO_reset$, "R"
 214                                       STRING TDC_loopback$, "M"
 214                                 cmds: 
 214                                       ;; CMD_multiarg (multiarg)
 214  2116D                                LOAD&RETURN s1, 6D[multiarg$:"m"]
 215  21175                                LOAD&RETURN s1, 75[multiarg$:"u"]
 216  2116C                                LOAD&RETURN s1, 6C[multiarg$:"l"]
 217  21174                                LOAD&RETURN s1, 74[multiarg$:"t"]
 218  21169                                LOAD&RETURN s1, 69[multiarg$:"i"]
 219  21161                                LOAD&RETURN s1, 61[multiarg$:"a"]
 21A  21172                                LOAD&RETURN s1, 72[multiarg$:"r"]
 21B  21167                                LOAD&RETURN s1, 67[multiarg$:"g"]
 21C  21100                                LOAD&RETURN s1, 00                               ; end of command
 21D  21101                                LOAD&RETURN s1, 01[CMD_multiarg'upper]
 21E  2112F                                LOAD&RETURN s1, 2F[CMD_multiarg'lower]
 21F                                       ;; CMD_Mem_dump (memdump)
 21F  2116D                                LOAD&RETURN s1, 6D[memdump$:"m"]
 220  21165                                LOAD&RETURN s1, 65[memdump$:"e"]
 221  2116D                                LOAD&RETURN s1, 6D[memdump$:"m"]
 222  21164                                LOAD&RETURN s1, 64[memdump$:"d"]
 223  21175                                LOAD&RETURN s1, 75[memdump$:"u"]
 224  2116D                                LOAD&RETURN s1, 6D[memdump$:"m"]
 225  21170                                LOAD&RETURN s1, 70[memdump$:"p"]
 226  21100                                LOAD&RETURN s1, 00                               ; end of command
 227  21101                                LOAD&RETURN s1, 01[CMD_Mem_dump'upper]
 228  21111                                LOAD&RETURN s1, 11[CMD_Mem_dump'lower]
 229                                       ;; CMD_reset (reset)
 229  21172                                LOAD&RETURN s1, 72[reset$:"r"]
 22A  21165                                LOAD&RETURN s1, 65[reset$:"e"]
 22B  21173                                LOAD&RETURN s1, 73[reset$:"s"]
 22C  21165                                LOAD&RETURN s1, 65[reset$:"e"]
 22D  21174                                LOAD&RETURN s1, 74[reset$:"t"]
 22E  21100                                LOAD&RETURN s1, 00                               ; end of command
 22F  21101                                LOAD&RETURN s1, 01[CMD_reset'upper]
 230  21154                                LOAD&RETURN s1, 54[CMD_reset'lower]
 231                                       ;; CMD_Version (version)
 231  21176                                LOAD&RETURN s1, 76[version$:"v"]
 232  21165                                LOAD&RETURN s1, 65[version$:"e"]
 233  21172                                LOAD&RETURN s1, 72[version$:"r"]
 234  21173                                LOAD&RETURN s1, 73[version$:"s"]
 235  21169                                LOAD&RETURN s1, 69[version$:"i"]
 236  2116F                                LOAD&RETURN s1, 6F[version$:"o"]
 237  2116E                                LOAD&RETURN s1, 6E[version$:"n"]
 238  21100                                LOAD&RETURN s1, 00                               ; end of command
 239  21102                                LOAD&RETURN s1, 02[CMD_version'upper]
 23A  21109                                LOAD&RETURN s1, 09[CMD_version'lower]
 23B                                       ;; CMD_sys (sys)
 23B  21173                                LOAD&RETURN s1, 73[sys$:"s"]
 23C  21179                                LOAD&RETURN s1, 79[sys$:"y"]
 23D  21173                                LOAD&RETURN s1, 73[sys$:"s"]
 23E  21100                                LOAD&RETURN s1, 00                               ; end of command
 23F  21101                                LOAD&RETURN s1, 01[CMD_sys'upper]
 240  21188                                LOAD&RETURN s1, 88[CMD_sys'lower]
 241                                       ;; CMD_help (help)
 241  21168                                LOAD&RETURN s1, 68[help$:"h"]
 242  21165                                LOAD&RETURN s1, 65[help$:"e"]
 243  2116C                                LOAD&RETURN s1, 6C[help$:"l"]
 244  21170                                LOAD&RETURN s1, 70[help$:"p"]
 245  21100                                LOAD&RETURN s1, 00                               ; end of command
 246  21100                                LOAD&RETURN s1, 00[CMD_help'upper]
 247  211FF                                LOAD&RETURN s1, FF[CMD_help'lower]
 248                                       ;; CMD_dac
 248  21164                                LOAD&RETURN s1, 64[dac$:"d"]
 249  21100                                LOAD&RETURN s1, 00                               ; end of command
 24A  21100                                LOAD&RETURN s1, 00[CMD_dac'upper]
 24B  211C2                                LOAD&RETURN s1, C2[CMD_dac'lower]
 24C                                       ;; CMD_channel
 24C  21163                                LOAD&RETURN s1, 63[channel$:"c"]
 24D  21100                                LOAD&RETURN s1, 00                               ; end of command
 24E  21100                                LOAD&RETURN s1, 00[CMD_channel'upper]
 24F  211AB                                LOAD&RETURN s1, AB[CMD_channel'lower]
 250                                       ;; CMD_fire
 250  21173                                LOAD&RETURN s1, 73[fire$:"s"]
 251  21100                                LOAD&RETURN s1, 00                               ; end of command
 252  21100                                LOAD&RETURN s1, 00[CMD_fire'upper]
 253  211C8                                LOAD&RETURN s1, C8[CMD_fire'lower]
 254                                       ;; CMD_rapid_on
 254  2116E                                LOAD&RETURN s1, 6E[rapid_on$:"n"]
 255  21100                                LOAD&RETURN s1, 00                               ; end of command
 256  21101                                LOAD&RETURN s1, 01[CMD_rapid_on'upper]
 257  21156                                LOAD&RETURN s1, 56[CMD_rapid_on'lower]
 258                                       ;; CMD_rapid_off
 258  2116D                                LOAD&RETURN s1, 6D[rapid_off$:"m"]
 259  21100                                LOAD&RETURN s1, 00                               ; end of command
 25A  21101                                LOAD&RETURN s1, 01[CMD_rapid_off'upper]
 25B  21159                                LOAD&RETURN s1, 59[CMD_rapid_off'lower]
 25C                                       ;; CMD_cont_start
 25C  21161                                LOAD&RETURN s1, 61[cont_start$:"a"]
 25D  21100                                LOAD&RETURN s1, 00                               ; end of command
 25E  21100                                LOAD&RETURN s1, 00[CMD_cont_start'upper]
 25F  211BC                                LOAD&RETURN s1, BC[CMD_cont_start'lower]
 260                                       ;; CMD_cont_stop
 260  2117A                                LOAD&RETURN s1, 7A[cont_stop$:"z"]
 261  21100                                LOAD&RETURN s1, 00                               ; end of command
 262  21100                                LOAD&RETURN s1, 00[CMD_cont_stop'upper]
 263  211BF                                LOAD&RETURN s1, BF[CMD_cont_stop'lower]
 264                                       ;; CMD_period
 264  21170                                LOAD&RETURN s1, 70[period$:"p"]
 265  21100                                LOAD&RETURN s1, 00                               ; end of command
 266  21101                                LOAD&RETURN s1, 01[CMD_period'upper]
 267  2113A                                LOAD&RETURN s1, 3A[CMD_period'lower]
 268                                       ;; CMD_pulse_period
 268  21174                                LOAD&RETURN s1, 74[pulse_period$:"t"]
 269  21100                                LOAD&RETURN s1, 00                               ; end of command
 26A  21101                                LOAD&RETURN s1, 01[CMD_pulse_period'upper]
 26B  21147                                LOAD&RETURN s1, 47[CMD_pulse_period'lower]
 26C                                       ;; CMD_GEN_C5
 26C  21143                                LOAD&RETURN s1, 43[GEN_C5$:"C"]
 26D  21143                                LOAD&RETURN s1, 43[GEN_C5$:"C"]
 26E  21100                                LOAD&RETURN s1, 00                               ; end of command
 26F  21100                                LOAD&RETURN s1, 00[CMD_GEN_C5'upper]
 270  211F8                                LOAD&RETURN s1, F8[CMD_GEN_C5'lower]
 271                                       ;; CMD_GEN_D5
 271  21143                                LOAD&RETURN s1, 43[GEN_D5$:"C"]
 272  21144                                LOAD&RETURN s1, 44[GEN_D5$:"D"]
 273  21100                                LOAD&RETURN s1, 00                               ; end of command
 274  21100                                LOAD&RETURN s1, 00[CMD_GEN_D5'upper]
 275  211FC                                LOAD&RETURN s1, FC[CMD_GEN_D5'lower]
 276                                       ;; CMD_FIFO_flags
 276  21146                                LOAD&RETURN s1, 46[FIFO_flags$:"F"]
 277  21100                                LOAD&RETURN s1, 00                               ; end of command
 278  21100                                LOAD&RETURN s1, 00[CMD_FIFO_flags'upper]
 279  211CD                                LOAD&RETURN s1, CD[CMD_FIFO_flags'lower]
 27A                                       ;; CMD_FIFO_read
 27A  21144                                LOAD&RETURN s1, 44[FIFO_read$:"D"]
 27B  21100                                LOAD&RETURN s1, 00                               ; end of command
 27C  21100                                LOAD&RETURN s1, 00[CMD_FIFO_read'upper]
 27D  211D1                                LOAD&RETURN s1, D1[CMD_FIFO_read'lower]
 27E                                       ;; CMD_FIFO_reset
 27E  21152                                LOAD&RETURN s1, 52[FIFO_reset$:"R"]
 27F  21100                                LOAD&RETURN s1, 00                               ; end of command
 280  21100                                LOAD&RETURN s1, 00[CMD_FIFO_reset'upper]
 281  211F0                                LOAD&RETURN s1, F0[CMD_FIFO_reset'lower]
 282                                       ;; CMD_TDC_loopback
 282  2114D                                LOAD&RETURN s1, 4D[TDC_loopback$:"M"]
 283  21100                                LOAD&RETURN s1, 00                               ; end of command
 284  21101                                LOAD&RETURN s1, 01[CMD_TDC_loopback'upper]
 285  211FC                                LOAD&RETURN s1, FC[CMD_TDC_loopback'lower]
 286  211FF                                LOAD&RETURN s1, FF                               ; end of commands string
 287                                       ;;; ============================================================================
 287                                       ;;; Find function to call, parse arguemtns and then call it
 287                                       ;;; ============================================================================
 287                             cmd_find: 
 287  01B02                                LOAD sB, 02[cmds'upper]
 288  01A14                                LOAD sA, 14[cmds'lower]
 289  01200                                LOAD s2, 00[CLI_BUFFER_START]
 28A                        cmd_find_loop: 
 28A                                       ;; process next cmds char
 28A  24BA0                                CALL@ (sB, sA)                                   ; load next cmds char into s1
 28B  1D100                                COMPARE s1, 00                                   ; check for end of command
 28C  322A5                                JUMP Z, 2A5[cmd_find_call]
 28D  1D1FF                                COMPARE s1, FF                                   ; check for no more commands
 28E  322B2                                JUMP Z, 2B2[cmd_find_failed]
 28F                                       ;; process next CLI_BUFFER char
 28F  0B020                                FETCH s0, 20[CLI_BUFFER]                         ; get the end of buffer ptr
 290  1C200                                COMPARE s2, s0                                   ; check for overflow
 291  3E299                                JUMP NC, 299[cmd_find_next]
 292                                       ;; compare cmd/buffer chars
 292  0A020                                FETCH s0, (s2)                                   ; fetch the buffer's char
 293  1C010                                COMPARE s0, s1                                   ; compare it to the current cmd
 294  36299                                JUMP NZ, 299[cmd_find_next]                      ; move on to next command if not equal
 295  11201                                ADD s2, 01                                       ; move on to next char if equal
 296  11A01                                ADD sA, 01
 297  13B00                                ADDCY sB, 00
 298  2228A                                JUMP 28A[cmd_find_loop]
 299                        cmd_find_next: 
 299                                       ;; find the next command
 299  24BA0                                CALL@ (sB, sA)                                   ; load next cmds char into s1
 29A  1D1FF                                COMPARE s1, FF                                   ; check for no more commands
 29B  322B2                                JUMP Z, 2B2[cmd_find_failed]
 29C  1D100                                COMPARE s1, 00                                   ; check for end of command
 29D  322A1                                JUMP Z, 2A1[cmd_find_next_reset]
 29E  11A01                                ADD sA, 01
 29F  13B00                                ADDCY sB, 00
 2A0  22299                                JUMP 299[cmd_find_next]
 2A1                  cmd_find_next_reset: 
 2A1                                       ;; move to the start of the next command
 2A1  11A03                                ADD sA, 03
 2A2  13B00                                ADDCY sB, 00
 2A3                                       ;; reset CLI_BUFFER pointer
 2A3  01200                                LOAD s2, 00[CLI_BUFFER_START]
 2A4  2228A                                JUMP 28A[cmd_find_loop]
 2A5                        cmd_find_call: 
 2A5                                       ;; call tokenizer
 2A5  202B6                                CALL 2B6[cmd_tokenize]
 2A6  20305                                CALL 305[cmd_parse_tokens]
 2A7                                       ;; get command we are suppose to call
 2A7  11A01                                ADD sA, 01
 2A8  13B00                                ADDCY sB, 00
 2A9  24BA0                                CALL@ (sB, sA)
 2AA  00210                                LOAD s2, s1
 2AB  11A01                                ADD sA, 01
 2AC  13B00                                ADDCY sB, 00
 2AD  24BA0                                CALL@ (sB, sA)
 2AE                                       ;; call the actual command
 2AE  24210                                CALL@ (s2, s1)
 2AF                                       ;; get ready for new user commands
 2AF  200A7                                CALL 0A7[soft_reset]
 2B0  20062                                CALL 062[util_print_prompt]
 2B1  25000                                RETURN 
 2B2                      cmd_find_failed: 
 2B2  200A7                                CALL 0A7[soft_reset]
 2B3  202ED                                CALL 2ED[cmd_invalid]
 2B4  20062                                CALL 062[util_print_prompt]
 2B5  25000                                RETURN 
 2B6                                       ;;; ============================================================================
 2B6                                       ;;; Search through string for 4 sequences of hex data
 2B6                                       ;; seaches through CLI_BUFFER using s2 to start
 2B6                                       ;; this will reset CLI_COUNT,CLI_WORD_*_POS,CLI_WORD_*_SIZE,CLI_WORD_*
 2B6                                       ;; uses s0,s1,s2,s3
 2B6                                       ;;; ============================================================================
 2B6                         cmd_tokenize: 
 2B6                                       ;; initialize CLI_COUNT to zero
 2B6  01000                                LOAD s0, 00
 2B7  2F023                                STORE s0, 23[CLI_COUNT]
 2B8                    cmd_tokenize_loop: 
 2B8                                       ;; search through the buffer for hex data
 2B8  0B120                                FETCH s1, 20[CLI_BUFFER]                         ; get end of valid buffer data
 2B9  1C210                                COMPARE s2, s1
 2BA  3E2E0                                JUMP NC, 2E0[cmd_tokenize_end]                   ; jump to the end if we run out of buffer
 2BB  0A020                                FETCH s0, (s2)                                   ; get next char
 2BC  11201                                ADD s2, 01                                       ; move forward in the buffer (for next time)
 2BD  20031                                CALL 031[util_char_to_nibble]                    ; check if currenc char is valid hex
 2BE  3E2B8                                JUMP NC, 2B8[cmd_tokenize_loop]                  ; non-ascii char, keep looking
 2BF  19201                                SUB s2, 01                                       ; move back in s2 since we want to be at the beginning of the hex string
 2C0                                       ;; found hex data. Update CLI_COUNT
 2C0  0B023                                FETCH s0, 23[CLI_COUNT]                          ; Get the number of words
 2C1  11001                                ADD s0, 01                                       ; Update the number of valid words
 2C2  1D005                                COMPARE s0, 05                                   ; check if we've reached our max
 2C3  322E0                                JUMP Z, 2E0[cmd_tokenize_end]                    ; end if we have
 2C4  2F023                                STORE s0, 23[CLI_COUNT]                          ; update CLI_COUNT
 2C5                                       ;; Start a new word by recording the position in CLI_WORD_*_POS
 2C5  01123                                LOAD s1, 23[CLI_COUNT]                           ; Load the CLI_COUNT address into s1
 2C6  10100                                ADD s1, s0                                       ; move forward in address by the current number of valid words (in s0)
 2C7  2E210                                STORE s2, (s1)                                   ; Write to this address the position of this word
 2C8  00320                                LOAD s3, s2                                      ; store the max position we an search to for valid hex
 2C9  11308                                ADD s3, 08                                       ; first assume that the hex string is 8 chars
 2CA  0B120                                FETCH s1, 20[CLI_BUFFER]                         ; now get the end of the buffer
 2CB  1C310                                COMPARE s3, s1                                   ; we have to make sure we don't walk off the buffer,
 2CC  3A2CE                                JUMP C, 2CE[cmd_tokenize_size]                   ; so compare the 8 char assumption to the buffer size
 2CD  00310                                LOAD s3, s1                                      ; and truncate if needed
 2CE                    cmd_tokenize_size: 
 2CE                                       ;; count number of hex digits (nibbles) in this word
 2CE  1C320                                COMPARE s3, s2                                   ; check if we've gone too far
 2CF  322D5                                JUMP Z, 2D5[cmd_tokenize_size_end]
 2D0  0A020                                FETCH s0, (s2)
 2D1  20031                                CALL 031[util_char_to_nibble]                    ; check if currenc char is valid hex
 2D2  3E2D5                                JUMP NC, 2D5[cmd_tokenize_size_end]              ; non-ascii char, go search for the next word
 2D3  11201                                ADD s2, 01                                       ; move forward in the string
 2D4  222CE                                JUMP 2CE[cmd_tokenize_size]
 2D5                cmd_tokenize_size_end: 
 2D5                                       ;; store the size of this word's data
 2D5  00320                                LOAD s3, s2                                      ; store our current position in s3
 2D6  0B123                                FETCH s1, 23[CLI_COUNT]                          ; Load the count number to let us fetch this word's start position
 2D7  11124                                ADD s1, 24[CLI_WORD_1_POS]                       ; Add the count to CLI_WORD_1_POS
 2D8  19101                                SUB s1, 01                                       ; move back one because count = 1 puts us in work 2 pos
 2D9  0A010                                FETCH s0, (s1)                                   ; fetch the start pointer for this word
 2DA  18300                                SUB s3, s0                                       ; computer the number of nibbles for this word
 2DB  0B023                                FETCH s0, 23[CLI_COUNT]                          ; computer the position of the current word's
 2DC  11028                                ADD s0, 28[CLI_WORD_1_SIZE]                      ; add the size 1 address
 2DD  19001                                SUB s0, 01                                       ; remove 1 because count starts at 1
 2DE  2E300                                STORE s3, (s0)                                   ; store the current word's size
 2DF  222B8                                JUMP 2B8[cmd_tokenize_loop]
 2E0                     cmd_tokenize_end: 
 2E0  25000                                RETURN 
 2E1                                       ;;; ============================================================================
 2E1                                       ;;; Prints "Bad command" to UART
 2E1                                       ;; uses s0-s1,sA-sB
 2E1                                       ;;; ============================================================================
 2E1                                       STRING BadCommand$, "Bad command"                ; string data
 2E1                       str_BadCommand: ; string function
 2E1  21142                                LOAD&RETURN s1, 42[BadCommand$:"B"]
 2E2  21161                                LOAD&RETURN s1, 61[BadCommand$:"a"]
 2E3  21164                                LOAD&RETURN s1, 64[BadCommand$:"d"]
 2E4  21120                                LOAD&RETURN s1, 20[BadCommand$:" "]
 2E5  21163                                LOAD&RETURN s1, 63[BadCommand$:"c"]
 2E6  2116F                                LOAD&RETURN s1, 6F[BadCommand$:"o"]
 2E7  2116D                                LOAD&RETURN s1, 6D[BadCommand$:"m"]
 2E8  2116D                                LOAD&RETURN s1, 6D[BadCommand$:"m"]
 2E9  21161                                LOAD&RETURN s1, 61[BadCommand$:"a"]
 2EA  2116E                                LOAD&RETURN s1, 6E[BadCommand$:"n"]
 2EB  21164                                LOAD&RETURN s1, 64[BadCommand$:"d"]
 2EC  21100                                LOAD&RETURN s1, 00
 2ED                          cmd_invalid: 
 2ED  01B02                                LOAD sB, 02[str_BadCommand'upper]                ; Load sB,sA to str function address
 2EE  01AE1                                LOAD sA, E1[str_BadCommand'lower]
 2EF  20066                                CALL 066[util_print_string]
 2F0  2005B                                CALL 05B[util_print_EOL]
 2F1  25000                                RETURN 
 2F2                                       ;;; ============================================================================
 2F2                                       ;;; Prints "Error s2" to UART
 2F2                                       ;; molests s0-s2,sA-sB
 2F2                                       ;;; EXTRA FUNCTIONALITY
 2F2                                       ;; if you want to quickly end a cmd_"subroutine" which has been
 2F2                                       ;; called using CALL, JUMP to this code instead.
 2F2                                       ;;; ============================================================================
 2F2                                       STRING Error$, "Error: "
 2F2                            str_Error: 
 2F2  21145                                LOAD&RETURN s1, 45[Error$:"E"]
 2F3  21172                                LOAD&RETURN s1, 72[Error$:"r"]
 2F4  21172                                LOAD&RETURN s1, 72[Error$:"r"]
 2F5  2116F                                LOAD&RETURN s1, 6F[Error$:"o"]
 2F6  21172                                LOAD&RETURN s1, 72[Error$:"r"]
 2F7  2113A                                LOAD&RETURN s1, 3A[Error$:":"]
 2F8  21120                                LOAD&RETURN s1, 20[Error$:" "]
 2F9  21100                                LOAD&RETURN s1, 00
 2FA                            cmd_error: 
 2FA  01B02                                LOAD sB, 02[str_Error'upper]                     ; Load sB,sA to str function address
 2FB  01AF2                                LOAD sA, F2[str_Error'lower]
 2FC  20066                                CALL 066[util_print_string]
 2FD                                       ;; convert s2 into hex and print it as an error number
 2FD  00020                                LOAD s0, s2
 2FE  20043                                CALL 043[util_byte_to_hex]
 2FF  20002                                CALL 002[uart_output_wait]
 300  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 301  20002                                CALL 002[uart_output_wait]
 302  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 303  2005B                                CALL 05B[util_print_EOL]
 304  25000                                RETURN 
 305                                       ;;; ============================================================================
 305                                       ;;; Parses the data at the tokens and puts them in CLI_WORD_*
 305                                       ;;; ============================================================================
 305                     cmd_parse_tokens: 
 305  01238                                LOAD s2, 38[CLI_WORD_4]
 306  11204                                ADD s2, 04                                       ;load end of parsed words pointer
 307  0112C                                LOAD s1, 2C[CLI_WORD_1]                          ;load start of parsed words pointer
 308                cmd_parse_tokens_zero: 
 308  01000                                LOAD s0, 00
 309  2E010                                STORE s0, (s1)                                   ;zero word data
 30A  11101                                ADD s1, 01
 30B  1C120                                COMPARE s1, s2                                   ;check that we are still below the end ptr
 30C  3A308                                JUMP C, 308[cmd_parse_tokens_zero]
 30D                                       ;; begin parsing
 30D  01400                                LOAD s4, 00                                      ; store the offset to the current word
 30E          cmd_parse_tokens_next_token: 
 30E  0B023                                FETCH s0, 23[CLI_COUNT]                          ; store the number of words to parse
 30F  1C400                                COMPARE s4, s0
 310  3E330                                JUMP NC, 330[cmd_parse_tokens_done]              ; jump to done when we are through the counts
 311                                       ;; find the start of the buffer
 311  01024                                LOAD s0, 24[CLI_WORD_1_POS]                      ; Get the position of the first pos
 312  10040                                ADD s0, s4                                       ; Move to the current pos
 313  0A500                                FETCH s5, (s0)                                   ; get the start of the word buffer
 314                                       ;; find the end of the buffer
 314  01128                                LOAD s1, 28[CLI_WORD_1_SIZE]
 315  10140                                ADD s1, s4                                       ; find size of this word in nibbles
 316  0A610                                FETCH s6, (s1)
 317  10650                                ADD s6, s5                                       ; move size past the start
 318                                       ;; find the place we are storing the binary data
 318  00740                                LOAD s7, s4                                      ; load the word number (-1)
 319  14706                                SL0 s7
 31A  14706                                SL0 s7                                           ; multiply by 4 since thats how many bytes we allocate
 31B  1172C                                ADD s7, 2C[CLI_WORD_1]                           ; move to the byte after this word
 31C                                       ;; update word index for next time
 31C  11401                                ADD s4, 01
 31D               cmd_parse_tokens_parse: 
 31D  19602                                SUB s6, 02                                       ; move back a byte of data in the buffer
 31E  3A30E                                JUMP C, 30E[cmd_parse_tokens_next_token]         ; catch bug for 1 char command
 31F                                       ; the SUB 02 instruction would do a buffer underflow on this
 31F  1C650                                COMPARE s6, s5                                   ; check that we have a full byte to parse
 320  3A329                                JUMP C, 329[cmd_parse_nibble]
 321                                       ;; parse a byte
 321  0A260                                FETCH s2, (s6)
 322  11601                                ADD s6, 01
 323  0A160                                FETCH s1, (s6)
 324  19601                                SUB s6, 01
 325  2001E                                CALL 01E[util_hex_to_byte]                       ; convert two hex digits to hex
 326  2E070                                STORE s0, (s7)                                   ; store this byte
 327  11701                                ADD s7, 01                                       ; move forward in data
 328  2231D                                JUMP 31D[cmd_parse_tokens_parse]
 329                     cmd_parse_nibble: 
 329  11601                                ADD s6, 01
 32A  1C650                                COMPARE s6, s5
 32B  3630E                                JUMP NZ, 30E[cmd_parse_tokens_next_token]        ; there isn't even a nibble to parse
 32C                                       ;; parse the nibble
 32C  0A060                                FETCH s0, (s6)
 32D  20031                                CALL 031[util_char_to_nibble]
 32E  2E070                                STORE s0, (s7)
 32F  2230E                                JUMP 30E[cmd_parse_tokens_next_token]
 330                cmd_parse_tokens_done: 
 330  25000                                RETURN 
 331                                       ;;; ============================================================================
 331                                       ;;; Main UART UI LOOP
 331                                       ;; uses s0-s1
 331                                       ;;; ============================================================================
 331                             cli_loop: 
 331  20006                                CALL 006[uart_input_wait]                        ; wait for input
 332  09001                                INPUT s0, 01[UART_INPUT]                         ; read new char from UART
 333  0B120                                FETCH s1, 20[CLI_BUFFER]                         ; get current write pointer
 334  11100                                ADD s1, 00[CLI_BUFFER_START]                     ; add CLI_BUFFER_START
 335  2E010                                STORE s0, (s1)                                   ; store input in CLI_BUFFER
 336  0B120                                FETCH s1, 20[CLI_BUFFER]                         ; update CLI_BUFFER
 337  11101                                ADD s1, 01
 338  2F120                                STORE s1, 20[CLI_BUFFER]                         ;
 339  1D120                                COMPARE s1, 20[CLI_BUFFER]                       ; check for CLI BUFFER overflow
 33A  3E348                                JUMP NC, 348[cli_overflow]
 33B  20350                                CALL 350[cli_process]                            ; process the new char
 33C                                       ; return C=1 if a command
 33C  38287                                CALL C, 287[cmd_find]                            ; process a new command
 33D  22331                                JUMP 331[cli_loop]
 33E                                       ;;; ============================================================================
 33E                                       ;;; Error for UI overflow
 33E                                       ;; uses s0-s1
 33E                                       ;;; ============================================================================
 33E                                       STRING overflow$, "Overflow!"
 33E                         str_overflow: 
 33E  2114F                                LOAD&RETURN s1, 4F[overflow$:"O"]
 33F  21176                                LOAD&RETURN s1, 76[overflow$:"v"]
 340  21165                                LOAD&RETURN s1, 65[overflow$:"e"]
 341  21172                                LOAD&RETURN s1, 72[overflow$:"r"]
 342  21166                                LOAD&RETURN s1, 66[overflow$:"f"]
 343  2116C                                LOAD&RETURN s1, 6C[overflow$:"l"]
 344  2116F                                LOAD&RETURN s1, 6F[overflow$:"o"]
 345  21177                                LOAD&RETURN s1, 77[overflow$:"w"]
 346  21121                                LOAD&RETURN s1, 21[overflow$:"!"]
 347  21100                                LOAD&RETURN s1, 00
 348                         cli_overflow: 
 348  2005B                                CALL 05B[util_print_EOL]
 349  01B03                                LOAD sB, 03[str_overflow'upper]
 34A  01A3E                                LOAD sA, 3E[str_overflow'lower]
 34B  20066                                CALL 066[util_print_string]
 34C  2005B                                CALL 05B[util_print_EOL]
 34D  200A7                                CALL 0A7[soft_reset]
 34E  20062                                CALL 062[util_print_prompt]
 34F  22331                                JUMP 331[cli_loop]
 350                                       ;;; ============================================================================
 350                                       ;;; parse the current text inputted by the user
 350                                       ;; check for special characters
 350                                       ;; echo back to use if needed
 350                                       ;; set C = 1 if the user pressed enter
 350                                       ;; uses s0-s1
 350                                       ;;; ============================================================================
 350                          cli_process: 
 350                                       ;; check last char for something special
 350  0B020                                FETCH s0, 20[CLI_BUFFER]
 351  19001                                SUB s0, 01
 352  0A100                                FETCH s1, (s0)                                   ; load the last ASCII into s0
 353  1D10D                                COMPARE s1, 0D                                   ; check for CR
 354  32366                                JUMP Z, 366[cli_process_cmd]
 355  1D10A                                COMPARE s1, 0A                                   ; check for LF
 356  32366                                JUMP Z, 366[cli_process_cmd]
 357  1D108                                COMPARE s1, 08                                   ; check for backspace
 358  3236D                                JUMP Z, 36D[cli_process_bs]
 359  1D120                                COMPARE s1, 20                                   ; check for other special char
 35A  3E361                                JUMP NC, 361[cli_process_text]                   ; jump for user text
 35B                                       ;; remove special char
 35B  0B020                                FETCH s0, 20[CLI_BUFFER]
 35C  19001                                SUB s0, 01
 35D  2F020                                STORE s0, 20[CLI_BUFFER]
 35E  01000                                LOAD s0, 00
 35F  1400C                                RR s0                                            ; set C to zero (no command)
 360  25000                                RETURN 
 361                     cli_process_text: 
 361  20002                                CALL 002[uart_output_wait]                       ; nothing special
 362  2D101                                OUTPUT s1, 01[UART_OUTPUT]                       ; echo char back to user
 363  01000                                LOAD s0, 00
 364  1400C                                RR s0                                            ; set C to zero (no command)
 365  25000                                RETURN 
 366                      cli_process_cmd: 
 366                                       ;; respond with EOL
 366  2005B                                CALL 05B[util_print_EOL]
 367                                       ;; remove the CR/LF character from memory
 367  0B020                                FETCH s0, 20[CLI_BUFFER]
 368  19001                                SUB s0, 01                                       ; remove CR/LF from memory
 369  2F020                                STORE s0, 20[CLI_BUFFER]
 36A                                       ;; return with C = 1
 36A  01001                                LOAD s0, 01
 36B  1400C                                RR s0                                            ; set C to one
 36C  25000                                RETURN 
 36D                       cli_process_bs: 
 36D  0B020                                FETCH s0, 20[CLI_BUFFER]                         ; check if there is anything to bs into
 36E  19002                                SUB s0, 02                                       ; because we've already moved 1 ahead in CLI_BUFFER
 36F  3A37C                                JUMP C, 37C[cli_process_bs_done]
 370                                       ;; update display
 370  20002                                CALL 002[uart_output_wait]
 371  01108                                LOAD s1, 08                                      ; backspace
 372  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 373  20002                                CALL 002[uart_output_wait]
 374  01120                                LOAD s1, 20[" "]                                 ; blank (clears bad char)
 375  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 376  20002                                CALL 002[uart_output_wait]
 377  01108                                LOAD s1, 08
 378  2D101                                OUTPUT s1, 01[UART_OUTPUT]                       ; correctly sets next input char pos on screen
 379                                       ;; we need to remove a total of two chars from buffer (bad + bs)
 379                                       ;; remove one of them and leave one
 379  0B020                                FETCH s0, 20[CLI_BUFFER]
 37A  19001                                SUB s0, 01
 37B  2F020                                STORE s0, 20[CLI_BUFFER]
 37C                  cli_process_bs_done: 
 37C                                       ;; We need to remove one character from buffer
 37C  0B020                                FETCH s0, 20[CLI_BUFFER]
 37D  19001                                SUB s0, 01
 37E  2F020                                STORE s0, 20[CLI_BUFFER]
 37F                                       ;; set C to zero since there was no command
 37F  01000                                LOAD s0, 00
 380  1400C                                RR s0                                            ; set C to zero because there is no new command
 381  25000                                RETURN 



List of PSM files that have been assembled

Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cli.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\uart.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\utils.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\spi.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmd_names.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_C.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_D.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_F.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_G.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_H.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_M.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_P.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_R.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_S.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_T.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_V.psm



List of defined constants

 CONSTANT name               Value        Source PSM File

 timestamp_hours             14'd         
 timestamp_minutes           52'd         
 timestamp_seconds           40'd         
 datestamp_year              14'd         
 datestamp_month             2'd          
 datestamp_day               28'd         
 NUL                         00           
 BEL                         07           
 BS                          08           
 HT                          09           
 LF                          0A           
 VT                          0B           
 CR                          0D           
 ESC                         1B           
 DEL                         7F           
 DCS                         90           
 ST                          9C           
 CLI_BUFFER_START            00           cli.psm
 CLI_BUFFER                  20           cli.psm
 CLI_COUNT                   23           cli.psm
 CLI_WORD_1_POS              24           cli.psm
 CLI_WORD_2_POS              25           cli.psm
 CLI_WORD_3_POS              26           cli.psm
 CLI_WORD_4_POS              27           cli.psm
 CLI_WORD_1_SIZE             28           cli.psm
 CLI_WORD_2_SIZE             29           cli.psm
 CLI_WORD_3_SIZE             2A           cli.psm
 CLI_WORD_4_SIZE             2B           cli.psm
 CLI_WORD_1                  2C           cli.psm
 CLI_WORD_2                  30           cli.psm
 CLI_WORD_3                  34           cli.psm
 CLI_WORD_4                  38           cli.psm
 MEM_USER_1                  40           cli.psm
 MEM_USER_2                  80           cli.psm
 MEM_USER_3                  C0           cli.psm
 MEM_SIZE                    FF           cli.psm
 UI_VERSION                  01           cli.psm
 FIFO_data                   03           cli.psm
 FIFO_flags                  04           cli.psm
 UART_TX_RESET_PORT          00           cli.psm
 LED_PORT                    00000010'b   cli.psm
 SPI_PORT                    00000011'b   cli.psm
 ONCEPORT                    00000100'b   cli.psm
 INITPORT                    00000101'b   cli.psm
 PERIOD_PORT2                00000110'b   cli.psm
 PERIOD_PORT1                00000111'b   cli.psm
 PERIOD_PORT0                00001000'b   cli.psm
 PULSE_PERIOD_PORT2          00001001'b   cli.psm
 PULSE_PERIOD_PORT1          00001010'b   cli.psm
 PULSE_PERIOD_PORT0          00001011'b   cli.psm
 CTRL_port                   00001100'b   cli.psm
 C5_data                     00100000'b   cli.psm
 RESET_fifo_port             00100001'b   cli.psm
 spi_clk                     00000001'b   cli.psm
 spi_cs                      00000010'b   cli.psm
 spi_mosi                    10000000'b   cli.psm
 UART_STATUS                 00           uart.psm
 UART_INPUT                  01           uart.psm
 UART_OUTPUT                 01           uart.psm
 UART_STATUS_Tx_data_present 00000001'b   uart.psm
 UART_STATUS_Tx_half_full    00000010'b   uart.psm
 UART_STATUS_Tx_full         00000100'b   uart.psm
 UART_STATUS_Rx_data_present 00001000'b   uart.psm
 UART_STATUS_Rx_half_full    00010000'b   uart.psm
 UART_STATUS_Rx_full         00100000'b   uart.psm



No TABLEs defined



List of text strings

 STRING name       String             Source PSM File

 KCPSM6_version$   "v2.46"            
 datestamp$        "28 Feb 2014"      
 timestamp$        "14:52:40"         
 startup$          "CLI V:"           cli.psm
 BUFFER$           "Buffer: "         cmds_S.psm
 WORD_COUNT$       "Word count: "     cmds_S.psm
 WORD_SIZE$        "Word sizes:    "  cmds_S.psm
 WORD$             "Word "            cmds_S.psm
 ver$              "Version: "        cmds_V.psm
 multiarg$         "multiarg"         cmd_names.psm
 memdump$          "memdump"          cmd_names.psm
 reset$            "reset"            cmd_names.psm
 version$          "version"          cmd_names.psm
 sys$              "sys"              cmd_names.psm
 help$             "help"             cmd_names.psm
 dac$              "d"                cmd_names.psm
 channel$          "c"                cmd_names.psm
 fire$             "s"                cmd_names.psm
 rapid_on$         "n"                cmd_names.psm
 rapid_off$        "m"                cmd_names.psm
 cont_start$       "a"                cmd_names.psm
 cont_stop$        "z"                cmd_names.psm
 period$           "p"                cmd_names.psm
 pulse_period$     "t"                cmd_names.psm
 GEN_C5$           "CC"               cmd_names.psm
 GEN_D5$           "CD"               cmd_names.psm
 FIFO_flags$       "F"                cmd_names.psm
 FIFO_read$        "D"                cmd_names.psm
 FIFO_reset$       "R"                cmd_names.psm
 TDC_loopback$     "M"                cmd_names.psm
 BadCommand$       "Bad command"      cmds.psm
 Error$            "Error: "          cmds.psm
 overflow$         "Overflow!"        cli.psm



List of line labels

   Label                          Addr  Source PSM File

 * start                          000   cli.psm
   uart_output_wait               002   uart.psm
   uart_input_wait                006   uart.psm
 * uart_input_data                00C   uart.psm
 * uart_output_data               00F   uart.psm
 * uart_input_full                012   uart.psm
 * uart_output_full               015   uart.psm
 * uart_input_half_full           018   uart.psm
 * uart_output_half_full          01B   uart.psm
   util_hex_to_byte               01E   utils.psm
   util_hex_to_byte_error         02E   utils.psm
   util_char_to_nibble            031   utils.psm
   util_char_to_nibble_error      03F   utils.psm
   util_char_to_nibble_finish     042   utils.psm
   util_byte_to_hex               043   utils.psm
   util_byte_to_hex_next          04D   utils.psm
   util_byte_to_hex_end           054   utils.psm
   util_print_hex_byte            055   utils.psm
   util_print_EOL                 05B   utils.psm
   util_print_prompt              062   utils.psm
   util_print_string              066   utils.psm
   util_print_string_end          06E   utils.psm
   send_spi                       06F   spi.psm
   next_bit                       070   spi.psm
   clock_pulse                    07D   spi.psm
   sdelay                         085   spi.psm
   DLOOP                          087   spi.psm
   str_startup                    08A   cli.psm
   hard_reset                     091   cli.psm
   start_delay                    094   cli.psm
   soft_reset                     0A7   cli.psm
   CMD_channel                    0AB   cmds_C.psm
   CMD_cont_start                 0BC   cmds_C.psm
   CMD_cont_stop                  0BF   cmds_C.psm
   CMD_dac                        0C2   cmds_D.psm
   CMD_fire                       0C8   cmds_F.psm
   CMD_FIFO_flags                 0CD   cmds_F.psm
   CMD_FIFO_read                  0D1   cmds_F.psm
 * FIFO_read_all                  0D4   cmds_F.psm
   FIFO_read_len                  0D7   cmds_F.psm
   do_D_init_read                 0DB   cmds_F.psm
   do_D_read                      0DE   cmds_F.psm
   do_D_empty                     0EC   cmds_F.psm
   CMD_FIFO_reset                 0F0   cmds_F.psm
   Fdelay                         0F4   cmds_F.psm
   FDLOOP                         0F5   cmds_F.psm
   CMD_GEN_C5                     0F8   cmds_G.psm
   CMD_GEN_D5                     0FC   cmds_G.psm
   CMD_help                       0FF   cmds_H.psm
   CMD_help_loop                  101   cmds_H.psm
   CMD_help_eol                   10B   cmds_H.psm
   CMD_help_end                   10F   cmds_H.psm
   CMD_Mem_dump                   111   cmds_M.psm
   CMD_Mem_dump_loop              112   cmds_M.psm
   CMD_Mem_dump_line_loop         11E   cmds_M.psm
   CMD_Mem_dump_end               12D   cmds_M.psm
   CMD_multiarg                   12F   cmds_M.psm
   CMD_multiarg_end               139   cmds_M.psm
   CMD_period                     13A   cmds_P.psm
   CMD_pulse_period               147   cmds_P.psm
   CMD_reset                      154   cmds_R.psm
   CMD_rapid_on                   156   cmds_R.psm
   CMD_rapid_off                  159   cmds_R.psm
   str_BUFFER                     15C   cmds_S.psm
   str_WORD_COUNT                 165   cmds_S.psm
   str_WORD_SIZE                  172   cmds_S.psm
   str_WORD                       182   cmds_S.psm
   CMD_sys                        188   cmds_S.psm
   CMD_sys_buffer                 18D   cmds_S.psm
   CMD_sys_buffer_size            194   cmds_S.psm
 * CMD_sys_word_count             1A4   cmds_S.psm
   CMD_sys_word_pos               1B0   cmds_S.psm
   CMD_sys_word_size              1C2   cmds_S.psm
   CMD_sys_word_size_loop         1C8   cmds_S.psm
   CMD_sys_word                   1D7   cmds_S.psm
   CMD_sys_word_loop              1DA   cmds_S.psm
   CMD_sys_word_loop_print_loop   1F0   cmds_S.psm
   CMD_sys_word_end               1FA   cmds_S.psm
   CMD_TDC_loopback               1FC   cmds_T.psm
   str_ver                        1FF   cmds_V.psm
   CMD_version                    209   cmds_V.psm
   cmds                           214   cmd_names.psm
   cmd_find                       287   cmds.psm
   cmd_find_loop                  28A   cmds.psm
   cmd_find_next                  299   cmds.psm
   cmd_find_next_reset            2A1   cmds.psm
   cmd_find_call                  2A5   cmds.psm
   cmd_find_failed                2B2   cmds.psm
   cmd_tokenize                   2B6   cmds.psm
   cmd_tokenize_loop              2B8   cmds.psm
   cmd_tokenize_size              2CE   cmds.psm
   cmd_tokenize_size_end          2D5   cmds.psm
   cmd_tokenize_end               2E0   cmds.psm
   str_BadCommand                 2E1   cmds.psm
   cmd_invalid                    2ED   cmds.psm
   str_Error                      2F2   cmds.psm
 * cmd_error                      2FA   cmds.psm
   cmd_parse_tokens               305   cmds.psm
   cmd_parse_tokens_zero          308   cmds.psm
   cmd_parse_tokens_next_token    30E   cmds.psm
   cmd_parse_tokens_parse         31D   cmds.psm
   cmd_parse_nibble               329   cmds.psm
   cmd_parse_tokens_done          330   cmds.psm
   cli_loop                       331   cli.psm
   str_overflow                   33E   cli.psm
   cli_overflow                   348   cli.psm
   cli_process                    350   cli.psm
   cli_process_text               361   cli.psm
   cli_process_cmd                366   cli.psm
   cli_process_bs                 36D   cli.psm
   cli_process_bs_done            37C   cli.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            110
 STAR              -

 AND               6
 OR                4
 XOR               -

 ADD              58
 ADDCY             8
 SUB              23
 SUBCY             3

 TEST              8
 TESTCY            -
 COMPARE          36
 COMPARECY         -

 SL0              11
 SL1               -
 SLX               -
 SLA               1
 RL                -
 SR0               7
 SR1               -
 SRX               -
 SRA               -
 RR                4

 REGBANK           -

 INPUT            13
 OUTPUT           69
 OUTPUTK           2

 STORE            56
 FETCH            56

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             76
 JUMP@             -
 CALL            120
 CALL@             7
 RETURN           55
 LOAD&RETURN     206

 HWBUILD           -



End of KCPSM6 log file.
