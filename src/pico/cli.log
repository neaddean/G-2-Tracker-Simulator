KCPSM6 Assembler log file for program 'Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cli.psm'.
Generated by KCPSM6 version v2.46
Ken Chapman - Xilinx Ltd - 18th February 2013

Assembly datestamp: 19 Feb 2014
Assembly timestamp: 11:43:03

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 376 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 887
Memory locations available: 3209


Assembly listing

 Addr Code                                 Instruction

 000                                       ;;; ============================================================================
 000                                       ;;; EPP RAM test via UART UI
 000                                       ;; Dan Gastler
 000                                       ;; Boston University Electronics Design Facility
 000                                       ;; 2013-10-18 v1.0
 000                                       ;;; ============================================================================
 000                                       ;;; ============================================================================
 000                                       ;;; Register map
 000                                       ;;; ============================================================================
 000                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 000                                       ;;; | soft_reset | x  |    |
 000                                       ;;; | hard_reset | x  | x  | x  |    |    |    |    |    |    |    | x  |  x |
 000                                       ;;; | start  | x  | x  |
 000                                       ;;; | cli_loop   |
 000                                       ;;; | print_EOL  |
 000                                       ;;; ============================================================================
 000                                       ;;; Scratchpad memory map
 000                                       ;;; ============================================================================
 000                                       CONSTANT CLI_BUFFER_START, 00                    ; Start of the UART buffer
 000                                       CONSTANT CLI_BUFFER, 20                          ; Current write pointer in the CLI buffer
 000                                       CONSTANT CLI_COUNT, 23                           ; Number of valid parsed 16bit words on
 000                                       ; the command line
 000                                       CONSTANT CLI_WORD_1_POS, 24                      ; position in CLI_BUFFER where WORD1 starts
 000                                       CONSTANT CLI_WORD_2_POS, 25                      ; position in CLI_BUFFER where WORD2 starts
 000                                       CONSTANT CLI_WORD_3_POS, 26                      ; position in CLI_BUFFER where WORD3 starts
 000                                       CONSTANT CLI_WORD_4_POS, 27                      ; position in CLI_BUFFER where WORD4 starts
 000                                       CONSTANT CLI_WORD_1_SIZE, 28                     ; number of nibbles in this word
 000                                       CONSTANT CLI_WORD_2_SIZE, 29                     ; number of nibbles in this word
 000                                       CONSTANT CLI_WORD_3_SIZE, 2A                     ; number of nibbles in this word
 000                                       CONSTANT CLI_WORD_4_SIZE, 2B                     ; number of nibbles in this word
 000                                       CONSTANT CLI_WORD_1, 2C                          ; LSB of parsed word 1 (+ for MSB)
 000                                       CONSTANT CLI_WORD_2, 30                          ; LSB of parsed word 1
 000                                       CONSTANT CLI_WORD_3, 34                          ; LSB of parsed word 1
 000                                       CONSTANT CLI_WORD_4, 38                          ; LSB of parsed word 1
 000                                       CONSTANT MEM_USER_1, 40                          ; Start of User mem block 1
 000                                       CONSTANT MEM_USER_2, 80                          ; Start of User mem block 2
 000                                       CONSTANT MEM_USER_3, C0                          ; Start of User mem block 3
 000                                       CONSTANT MEM_SIZE, FF                            ; Size of our scratchpad memory
 000                                       ;;; ============================================================================
 000                                       ;;; Constants
 000                                       ;;; ============================================================================
 000                                       CONSTANT UI_VERSION, 01
 000                                       ;; input ports
 000                                       CONSTANT FIFO_data, 03
 000                                       CONSTANT FIFO_flags, 04
 000                                       ;; constant out ports
 000                                       CONSTANT UART_TX_RESET_PORT, 00
 000                                       ;; output ports
 000                                       CONSTANT INITPORT, 00001000'b
 000                                       CONSTANT ONCEPORT, 00001001'b
 000                                       CONSTANT LED_PORT, 00000010'b
 000                                       CONSTANT SPI_PORT, 00000011'b
 000                                       CONSTANT PERIOD_PORT0, 01000000'b
 000                                       CONSTANT PERIOD_PORT1, 01000001'b
 000                                       CONSTANT PERIOD_PORT2, 01000010'b
 000                                       CONSTANT PULSE_PERIOD_PORT0, 01000100'b
 000                                       CONSTANT PULSE_PERIOD_PORT1, 01000101'b
 000                                       CONSTANT PULSE_PERIOD_PORT2, 01000110'b
 000                                       CONSTANT CTRL_port, 00100000'b
 000                                       CONSTANT C5_data, 11100000'b
 000                                       CONSTANT RESET_fifo_port, 11100010'b
 000                                       ;; spi bits
 000                                       CONSTANT spi_clk, 00000001'b                     ;   spi_clk - bit0 (SPI_output_por0t)
 000                                       CONSTANT spi_cs, 00000010'b                      ;  spi_cs - bit1 (SPI_output_port)
 000                                       CONSTANT spi_mosi, 10000000'b                    ;  spi_mosi - bit7 (SPI_output_port)
 000                                       NAMEREG sC, SPI_HIGH
 000                                       NAMEREG sD, SPI_LOW
 000                                       ;;; ============================================================================
 000                                       ;;; START
 000                                       ;;; ============================================================================
 000                                start: 
 000  2008F                                CALL 08F[hard_reset]
 001  22326                                JUMP 326[cli_loop]
 002                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\uart.psm"["uart.psm"]
 002                                       ;;; ============================================================================
 002                                       ;;; Register map
 002                                       ;;; ============================================================================
 002                                       ;;; | name                  | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 002                                       ;;; | uart_output_wait      | x  |
 002                                       ;;; | uart_output_wait      | x  |
 002                                       ;;; | uart_input_data       | x  |
 002                                       ;;; | uart_output_data      | x  |
 002                                       ;;; | uart_input_full       | x  |
 002                                       ;;; | uart_output_full      | x  |
 002                                       ;;; | uart_input_half_full  | x  |
 002                                       ;;; | uart_output_half_full | x  |
 002                                       ;;; ============================================================================
 002                                       ;;; CONSTANTS
 002                                       ;;; ============================================================================
 002                                       ;;; UART ports
 002                                       CONSTANT UART_STATUS, 00                         ; Port with the RX/TX status bits
 002                                       CONSTANT UART_INPUT, 01                          ; 8bit reading port on microC
 002                                       CONSTANT UART_OUTPUT, 01                         ; 8bit writing port on microC
 002                                       ;;; uart status constants
 002                                       CONSTANT UART_STATUS_Tx_data_present, 00000001'b ; bit 0:  tx data present
 002                                       CONSTANT UART_STATUS_Tx_half_full, 00000010'b    ; bit 1:  tx half full (8 elements in FIFO)
 002                                       CONSTANT UART_STATUS_Tx_full, 00000100'b         ; bit 2:  tx full (16 elements in FIFO)
 002                                       CONSTANT UART_STATUS_Rx_data_present, 00001000'b ; bit 3:  rx data present
 002                                       CONSTANT UART_STATUS_Rx_half_full, 00010000'b    ; bit 4:  rx half full (8 elements in FIFO)
 002                                       CONSTANT UART_STATUS_Rx_full, 00100000'b         ; bit 5:  tx full (16 elements in FIFO)
 002                                       ;;; ============================================================================
 002                                       ;;; UART Tools
 002                                       ;;; ============================================================================
 002                                       ;;; wait for an available output space
 002                     uart_output_wait: 
 002  09000                                INPUT s0, 00[UART_STATUS]
 003  0D004                                TEST s0, 04[UART_STATUS_Tx_full]                 ; check if the tx FIFO is full
 004  31000                                RETURN Z
 005  22002                                JUMP 002[uart_output_wait]
 006                                       ;;; wait for UART input
 006                      uart_input_wait: 
 006  09000                                INPUT s0, 00[UART_STATUS]
 007                                       ;; INPUT  sF, FIFO_flags
 007                                       ;; OUTPUT sF, LED_PORT
 007  0D008                                TEST s0, 08[UART_STATUS_Rx_data_present]         ; check if the rx FIFO is full
 008  39000                                RETURN C
 009  22006                                JUMP 006[uart_input_wait]
 00A                                       ;;; Non-blocking tests
 00A                                       ;;; check if there is data to read, C=1 if true
 00A                      uart_input_data: 
 00A  09000                                INPUT s0, 00[UART_STATUS]
 00B  0D008                                TEST s0, 08[UART_STATUS_Rx_data_present]         ; test for input data
 00C  25000                                RETURN 
 00D                                       ;;; check if there is data in the FIFO to send, C=1 if true
 00D                     uart_output_data: 
 00D  09000                                INPUT s0, 00[UART_STATUS]
 00E  0D001                                TEST s0, 01[UART_STATUS_Tx_data_present]         ; test for output data
 00F  25000                                RETURN 
 010                                       ;;; check if the input buffer is full, C=1 if true
 010                      uart_input_full: 
 010  09000                                INPUT s0, 00[UART_STATUS]
 011  0D020                                TEST s0, 20[UART_STATUS_Rx_full]                 ; check if the rx FIFO is full
 012  25000                                RETURN 
 013                                       ;;; check if the output buffer is full, C=1 if true
 013                     uart_output_full: 
 013  09000                                INPUT s0, 00[UART_STATUS]
 014  0D004                                TEST s0, 04[UART_STATUS_Tx_full]                 ; check if the tx FIFO is full
 015  25000                                RETURN 
 016                                       ;;; check if the input buffer is half full, C=1 if true
 016                 uart_input_half_full: 
 016  09000                                INPUT s0, 00[UART_STATUS]
 017  0D010                                TEST s0, 10[UART_STATUS_Rx_half_full]            ; check if the rx FIFO is full
 018  25000                                RETURN 
 019                                       ;;; check if the output buffer is half full, C=1 if true
 019                uart_output_half_full: 
 019  09000                                INPUT s0, 00[UART_STATUS]
 01A  0D002                                TEST s0, 02[UART_STATUS_Tx_half_full]            ; check if the tx FIFO is full
 01B  25000                                RETURN 
 01C                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\utils.psm"["utils.psm"]
 01C                                       ;;; ============================================================================
 01C                                       ;;; Register map
 01C                                       ;;; ============================================================================
 01C                                       ;;; | name                     | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 01C                                       ;;; | util_hex_to_byte         | x  | x  | x  | x  |    |    |    |    |    |    |    |    |
 01C                                       ;;; | util_char_to_nibble      | x  |    |    |    |    |    |    |    |    |    |    |    |
 01C                                       ;;; | util_byte_to_hex         | x  | x  | x  |    |    |    |    |    |    |    |    |    |
 01C                                       ;;; | util_print_byte_to_hex   | x  | x  | x  |    |    |    |    |    |    |    |    |    |
 01C                                       ;;; | util_print_EOL           | x  | x  |    |    |    |    |    |    |    |    |    |    |
 01C                                       ;;; | util_print_prompt        | x  | x  |    |    |    |    |    |    |    |    |    |    |
 01C                                       ;;; | util_print_string        | x  | x  |    |    |    |    |    |    |    |    | x  | x  |
 01C                                       ;;;
 01C                                       ;;; ============================================================================
 01C                                       ;;; Convert two bytes of ascii to hex
 01C                                       ;; return byte in s0, C=1 for sucess, C=0 for failure
 01C                                       ;; load two ASCII characters in s2(MSB),s1(LSB)
 01C                                       ;; this uses s0-s3
 01C                                       ;;; ============================================================================
 01C                     util_hex_to_byte: 
 01C                                       ;; check and convert MSB
 01C  00020                                LOAD s0, s2                                      ; Call util_char_to_nibble to convert and check this is hex
 01D  2002F                                CALL 02F[util_char_to_nibble]
 01E  3E02C                                JUMP NC, 02C[util_hex_to_byte_error]             ; jump to error if we failed
 01F                                       ;; store result in the MSBs of s3
 01F  00300                                LOAD s3, s0
 020  14306                                SL0 s3
 021  14306                                SL0 s3
 022  14306                                SL0 s3
 023  14306                                SL0 s3
 024                                       ;; check and convert LSB
 024  00010                                LOAD s0, s1
 025  2002F                                CALL 02F[util_char_to_nibble]
 026  3E02C                                JUMP NC, 02C[util_hex_to_byte_error]             ; jump to error if we failed
 027                                       ;; combine into s3,
 027  10300                                ADD s3, s0
 028                                       ;; we converted sucessfully, so set C=1 and return s3 in s0
 028  01001                                LOAD s0, 01
 029  1400E                                SR0 s0
 02A  00030                                LOAD s0, s3
 02B  25000                                RETURN 
 02C               util_hex_to_byte_error: 
 02C  01000                                LOAD s0, 00                                      ; set s0 to zero and C=0
 02D  1400E                                SR0 s0
 02E  25000                                RETURN 
 02F                                       ;;; ============================================================================
 02F                                       ;;; Check if char is a valid hex digit and convert it to a LSB nibble if it is
 02F                                       ;; C=1 for valid, C=0 for invalid
 02F                                       ;; load char from s0 (will be lost)
 02F                                       ;; returns nibble in s0
 02F                                       ;; uses s0
 02F                                       ;;; ============================================================================
 02F                  util_char_to_nibble: 
 02F  19030                                SUB s0, 30                                       ; Drop s0 to 0-9 if the number was ascii 0-9
 030                                       ;; if some lower character, throw an error
 030  3A03D                                JUMP C, 03D[util_char_to_nibble_error]
 031  1D00A                                COMPARE s0, 0A                                   ; check for 0-9
 032                                       ;; jump to finish if nibble in range 0-9
 032  3A040                                JUMP C, 040[util_char_to_nibble_finish]
 033  19011                                SUB s0, 11                                       ; Move ASCII A to zero and see if we roll over
 034                                       ;; if some lower character, throw an error
 034  3A03D                                JUMP C, 03D[util_char_to_nibble_error]
 035  1100A                                ADD s0, 0A                                       ; add 10 to bring ascii A-F to dec 10-15
 036  1D010                                COMPARE s0, 10                                   ; compare to dec 16
 037                                       ;; Jump to finish if nibble in range A-F
 037  3A040                                JUMP C, 040[util_char_to_nibble_finish]
 038  1902A                                SUB s0, 2A                                       ; bring ASCII a-f to dec 0-5
 039                                       ;; if some lower character, throw an error
 039  3A03D                                JUMP C, 03D[util_char_to_nibble_error]
 03A  1100A                                ADD s0, 0A                                       ; bring a-f to 10-15
 03B  1D010                                COMPARE s0, 10                                   ; compare to dec 16
 03C                                       ;; Jump to finish if nibble in range a-f
 03C  3A040                                JUMP C, 040[util_char_to_nibble_finish]
 03D                                       ;; other values are errors
 03D            util_char_to_nibble_error: 
 03D                                       ;; conversion failed, return s0=0 and C = 0
 03D  01000                                LOAD s0, 00
 03E  1400E                                SR0 s0
 03F  25000                                RETURN 
 040           util_char_to_nibble_finish: 
 040                                       ;; by my 1337 skillz (AKA: pure luck as I get to the part in the code),
 040                                       ;; C already is 1 and s0 is set... so return!
 040  25000                                RETURN 
 041                                       ;;; ============================================================================
 041                                       ;;; Convert one byte into two bytes of ASCII hex
 041                                       ;; loads s0
 041                                       ;; outputs s2,s1
 041                                       ;;; ============================================================================
 041                     util_byte_to_hex: 
 041                                       ;; convert MSNibble
 041  00200                                LOAD s2, s0
 042  1420E                                SR0 s2
 043  1420E                                SR0 s2
 044  1420E                                SR0 s2
 045  1420E                                SR0 s2
 046  11237                                ADD s2, 37                                       ; convert to A-F
 047  1D241                                COMPARE s2, 41
 048                                       ;; If this wasn't a-F (ie 0-9) it will greater than 40
 048  3E04B                                JUMP NC, 04B[util_byte_to_hex_next]
 049  3204B                                JUMP Z, 04B[util_byte_to_hex_next]
 04A  19207                                SUB s2, 07                                       ; convert to 0-9
 04B                util_byte_to_hex_next: 
 04B  00100                                LOAD s1, s0
 04C  0310F                                AND s1, 0F                                       ; convert to LSNibble
 04D  11137                                ADD s1, 37                                       ; convert to A-F
 04E  1D141                                COMPARE s1, 41                                   ; check if this is really A-F
 04F  3E052                                JUMP NC, 052[util_byte_to_hex_end]
 050  32052                                JUMP Z, 052[util_byte_to_hex_end]
 051  19107                                SUB s1, 07                                       ; convert to 0-9
 052                 util_byte_to_hex_end: 
 052  25000                                RETURN 
 053                                       ;;; ============================================================================
 053                                       ;;; Convert one byte into two bytes of ASCII hex
 053                                       ;; loads s0
 053                                       ;; outputs s2,s1
 053                                       ;;; ============================================================================
 053                  util_print_hex_byte: 
 053  20041                                CALL 041[util_byte_to_hex]
 054  20002                                CALL 002[uart_output_wait]
 055  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 056  20002                                CALL 002[uart_output_wait]
 057  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 058  25000                                RETURN 
 059                                       ;;; ============================================================================
 059                                       ;;; Write a new line on the UART screen
 059                                       ;;; ============================================================================
 059                       util_print_EOL: 
 059  0110D                                LOAD s1, 0D                                      ; CR
 05A  20002                                CALL 002[uart_output_wait]
 05B  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 05C  0110A                                LOAD s1, 0A                                      ; LF
 05D  20002                                CALL 002[uart_output_wait]
 05E  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 05F  25000                                RETURN 
 060                                       ;;; ============================================================================
 060                                       ;;; Output the CLI prompt
 060                                       ;;; ============================================================================
 060                    util_print_prompt: 
 060  20002                                CALL 002[uart_output_wait]                       ; prompt
 061  0113E                                LOAD s1, 3E[">"]
 062  2D101                                OUTPUT s1, 01[UART_OUTPUT]                       ; echo
 063  25000                                RETURN 
 064                                       ;;; ============================================================================
 064                                       ;;; Prints a NULL terminated string @ sB,sA
 064                                       ;;  uses s1,sA,sB
 064                                       ;;; ============================================================================
 064                    util_print_string: 
 064  24BA0                                CALL@ (sB, sA)
 065  1D100                                COMPARE s1, 00
 066  3206C                                JUMP Z, 06C[util_print_string_end]               ; jump to finish if we get 00
 067  20002                                CALL 002[uart_output_wait]                       ; print currenc char to screen
 068  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 069  11A01                                ADD sA, 01                                       ; move forward in our string
 06A  13B00                                ADDCY sB, 00
 06B  22064                                JUMP 064[util_print_string]
 06C                util_print_string_end: 
 06C  25000                                RETURN 
 06D                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\spi.psm"["spi.psm"]
 06D                                       ;;; ============================================================================
 06D                                       ;;; Register map
 06D                                       ;;; ============================================================================
 06D                                       ;;; | name                | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 06D                                       ;;; | send_spi            |    |    |    |    |    |    | x  | x  | x  |    |    |    |
 06D  01710                      send_spi: LOAD s7, 10
 06E  006C0                      next_bit: LOAD s6, sC[SPI_HIGH]
 06F  03680                                AND s6, 80[spi_mosi]
 070  2D603                                OUTPUT s6, 03[SPI_PORT]
 071  14D06                                SL0 sD[SPI_LOW]
 072  14C00                                SLA sC[SPI_HIGH]
 073  2007B                                CALL 07B[clock_pulse]
 074  19701                                SUB s7, 01
 075  3606E                                JUMP NZ, 06E[next_bit]
 076  01602                                LOAD s6, 02[spi_cs]
 077  05601                                OR s6, 01[spi_clk]
 078  2D603                                OUTPUT s6, 03[SPI_PORT]
 079  20083                                CALL 083[sdelay]
 07A  25000                                RETURN 
 07B                          clock_pulse: 
 07B  05601                                OR s6, 01[spi_clk]
 07C  20083                                CALL 083[sdelay]
 07D  2D603                                OUTPUT s6, 03[SPI_PORT]
 07E  036FE                                AND s6, FE[~spi_clk]
 07F  20083                                CALL 083[sdelay]
 080  2D603                                OUTPUT s6, 03[SPI_PORT]
 081  20083                                CALL 083[sdelay]
 082  25000                                RETURN 
 083                               sdelay: 
 083  01840                                LOAD s8, 40
 084  22085                                JUMP 085[DLOOP]
 085                                DLOOP: 
 085  19801                                SUB s8, 01
 086  36085                                JUMP NZ, 085[DLOOP]
 087  25000                                RETURN 
 088                                       ;;; ============================================================================
 088                                       ;;; Reset the hardware and software to initial conditions
 088                                       ;; uses s0 - s1
 088                                       ;;; ============================================================================
 088                                       STRING startup$, "CLI V:"
 088                          str_startup: 
 088  21143                                LOAD&RETURN s1, 43[startup$:"C"]
 089  2114C                                LOAD&RETURN s1, 4C[startup$:"L"]
 08A  21149                                LOAD&RETURN s1, 49[startup$:"I"]
 08B  21120                                LOAD&RETURN s1, 20[startup$:" "]
 08C  21156                                LOAD&RETURN s1, 56[startup$:"V"]
 08D  2113A                                LOAD&RETURN s1, 3A[startup$:":"]
 08E  21100                                LOAD&RETURN s1, 00
 08F                           hard_reset: 
 08F  2009E                                CALL 09E[soft_reset]
 090                                       ;; reset UART
 090  2B031                                OUTPUTK 03, 1[UART_OUTPUT]
 091  2B001                                OUTPUTK 00, 1[UART_OUTPUT]
 092                                       ;; print version
 092  01B00                                LOAD sB, 00[str_startup'upper]
 093  01A88                                LOAD sA, 88[str_startup'lower]
 094  20064                                CALL 064[util_print_string]
 095  01001                                LOAD s0, 01[UI_VERSION]
 096  20041                                CALL 041[util_byte_to_hex]
 097  20002                                CALL 002[uart_output_wait]
 098  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 099  20002                                CALL 002[uart_output_wait]
 09A  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 09B  20059                                CALL 059[util_print_EOL]
 09C  20060                                CALL 060[util_print_prompt]
 09D  25000                                RETURN 
 09E                                       ;;; ============================================================================
 09E                                       ;;; Reset the software to initial conditions
 09E                                       ;; uses s0
 09E                                       ;;; ============================================================================
 09E                           soft_reset: 
 09E                                       ;; reset UART Buffer
 09E  01000                                LOAD s0, 00
 09F  2F020                                STORE s0, 20[CLI_BUFFER]
 0A0  2F023                                STORE s0, 23[CLI_COUNT]
 0A1  25000                                RETURN 
 0A2                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds.psm"["cmds.psm"]
 0A2                                       ;;; ============================================================================
 0A2                                       ;;; Register map
 0A2                                       ;;; ============================================================================
 0A2                                       ;;; | name                | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0A2                                       ;;; | cmd_find            | x  | x  | x  | x  |    |    |    |    |    |    | x  | x  |
 0A2                                       ;;; | cmd_tokenize        | x  | x  | x  | x  |    |    |    |    |    |    |    |    |
 0A2                                       ;;; | cmd_invalid   | x  | x  |    |    |    |    |    |    |    |    | x  | x  |
 0A2                                       ;;; | cmd_Error    | x  | x  | x  |    |    |    |    |    |    |    | x  | x  |
 0A2                                       ;;; | cmd_parse_tokens    | x  | x  | x  | x  | x  | x  | x  | x  |    |    |    |    |
 0A2                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmd_names.psm"["cmd_names.psm"]
 0A2                                       ;;; ============================================================================
 0A2                                       ;;; Register map
 0A2                                       ;;; ============================================================================
 0A2                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0A2                                       ;;; | cmds       |    | x  |    |    |    |    |    |    |    |    |    |    |
 0A2                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_C.psm"["cmds_C.psm"]
 0A2                                       ;;; ============================================================================
 0A2                                       ;;; Register map
 0A2                                       ;;; ============================================================================
 0A2                                       ;;; | name          | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0A2                                       ;;; | CMD_channel   | x  | x  |    |    | x  |    |    |    |    |    |    |    |
 0A2                                       ;;; | CMD_con_start | x  |    |    |    |    |    |    |    |    |    |    |    |
 0A2                                       ;;; | CMD_con_stop  | x  |    |    |    |    |    |    |    |    |    |    |    |
 0A2                          CMD_channel: 
 0A2  0B02C                                FETCH s0, 2C[CLI_WORD_1]
 0A3  14006                                SL0 s0
 0A4  14006                                SL0 s0                                           ;shift address into place
 0A5  00400                                LOAD s4, s0                                      ;store address
 0A6  05480                                OR s4, 80                                        ;lsb
 0A7  01130                                LOAD s1, 30[CLI_WORD_2]                          ;pointer
 0A8  0A010                                FETCH s0, (s1)                                   ;fetch lsb of channel period
 0A9  2C040                                OUTPUT s0, (s4)                                  ;output lsb
 0AA  11401                                ADD s4, 01                                       ;next byte of address
 0AB  11101                                ADD s1, 01                                       ;next byte of channel period
 0AC  0A010                                FETCH s0, (s1)
 0AD  2C040                                OUTPUT s0, (s4)                                  ;middle byte
 0AE  11401                                ADD s4, 01
 0AF  11101                                ADD s1, 01                                       ;msb, 0X
 0B0  0A010                                FETCH s0, (s1)
 0B1  2C040                                OUTPUT s0, (s4)                                  ;msb
 0B2  25000                                RETURN 
 0B3                       CMD_cont_start: 
 0B3  010FF                                LOAD s0, FF
 0B4  2D008                                OUTPUT s0, 08[INITPORT]
 0B5  25000                                RETURN 
 0B6                        CMD_cont_stop: 
 0B6  01000                                LOAD s0, 00
 0B7  2D008                                OUTPUT s0, 08[INITPORT]
 0B8  25000                                RETURN 
 0B9                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_D.psm"["cmds_D.psm"]
 0B9                                       ;;; ============================================================================
 0B9                                       ;;; Register map
 0B9                                       ;;; ============================================================================
 0B9                                       ;;; | name         | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0B9                                       ;;; | CMD_dac      | x  |    |    |    |    |    |    |    |    |    |    |    |
 0B9                              CMD_dac: 
 0B9  0102C                                LOAD s0, 2C[CLI_WORD_1]
 0BA  0AD00                                FETCH sD[SPI_LOW], (s0)
 0BB  11001                                ADD s0, 01
 0BC  0AC00                                FETCH sC[SPI_HIGH], (s0)
 0BD  2006D                                CALL 06D[send_spi]
 0BE  25000                                RETURN 
 0BF                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_F.psm"["cmds_F.psm"]
 0BF                                       ;;; ============================================================================
 0BF                                       ;;; Register map
 0BF                                       ;;; ============================================================================
 0BF                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0BF                                       ;;; | CMD_fire   | x  |    |    |    |    |    |    |    |    |    |    |    |
 0BF                             CMD_fire: 
 0BF  010FF                                LOAD s0, FF
 0C0  2D009                                OUTPUT s0, 09[ONCEPORT]
 0C1  01000                                LOAD s0, 00
 0C2  2D009                                OUTPUT s0, 09[ONCEPORT]
 0C3  25000                                RETURN 
 0C4                       CMD_FIFO_flags: 
 0C4  09004                                INPUT s0, 04[FIFO_flags]
 0C5  20053                                CALL 053[util_print_hex_byte]
 0C6  20059                                CALL 059[util_print_EOL]
 0C7  25000                                RETURN 
 0C8                        CMD_FIFO_read: 
 0C8  0B023                                FETCH s0, 23[CLI_COUNT]
 0C9  01FFF                                LOAD sF, FF
 0CA  2DF02                                OUTPUT sF, 02[LED_PORT]
 0CB  20053                                CALL 053[util_print_hex_byte]
 0CC  20059                                CALL 059[util_print_EOL]
 0CD  1D001                                COMPARE s0, 01
 0CE  320D2                                JUMP Z, 0D2[FIFO_read_len]
 0CF                        FIFO_read_all: 
 0CF  01700                                LOAD s7, 00                                      ;set count 0020 by default
 0D0  01620                                LOAD s6, 20
 0D1  220D6                                JUMP 0D6[do_D_init_read]
 0D2                        FIFO_read_len: 
 0D2  0102C                                LOAD s0, 2C[CLI_WORD_1]
 0D3  0A600                                FETCH s6, (s0)
 0D4  11001                                ADD s0, 01
 0D5  0A700                                FETCH s7, (s0)
 0D6                       do_D_init_read: 
 0D6  01801                                LOAD s8, 01                                      ;byte counter
 0D7  0103C                                LOAD s0, 3C                                      ; write K.28.1 word that is missed by the FIFO
 0D8  20053                                CALL 053[util_print_hex_byte]
 0D9                            do_D_read: 
 0D9  09004                                INPUT s0, 04[FIFO_flags]
 0DA  03001                                AND s0, 01
 0DB  360E6                                JUMP NZ, 0E6[do_D_empty]                         ;go if empty
 0DC  09003                                INPUT s0, 03[FIFO_data]
 0DD  20053                                CALL 053[util_print_hex_byte]
 0DE  11801                                ADD s8, 01                                       ;increment byte coutner
 0DF  03803                                AND s8, 03                                       ;check module 4
 0E0  360D9                                JUMP NZ, 0D9[do_D_read]
 0E1  20059                                CALL 059[util_print_EOL]                         ;send CR after 4 bytes
 0E2  19601                                SUB s6, 01[1'd]                                  ;decrement word count
 0E3  1B700                                SUBCY s7, 00[0'd]
 0E4  360D9                                JUMP NZ, 0D9[do_D_read]
 0E5  25000                                RETURN 
 0E6                           do_D_empty: 
 0E6  01058                                LOAD s0, 58
 0E7  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 0E8  20059                                CALL 059[util_print_EOL]
 0E9  25000                                RETURN 
 0EA                       CMD_FIFO_reset: 
 0EA  2D0E2                                OUTPUT s0, E2[RESET_fifo_port]
 0EB  01F00                                LOAD sF, 00
 0EC  2DF02                                OUTPUT sF, 02[LED_PORT]
 0ED  25000                                RETURN 
 0EE                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_G.psm"["cmds_G.psm"]
 0EE                                       ;;; ============================================================================
 0EE                                       ;;; Register map
 0EE                                       ;;; ============================================================================
 0EE                                       ;;; | name          | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0EE                                       ;;; | CMD_GEN_C5    | x  | x  |    |    |    |    |    |    |    |    |    |    |
 0EE                           CMD_GEN_C5: 
 0EE  0B02C                                FETCH s0, 2C[CLI_WORD_1]
 0EF  05010                                OR s0, 10                                        ;set bit 4 for C code
 0F0  2D0E0                                OUTPUT s0, E0[C5_data]
 0F1  25000                                RETURN 
 0F2                           CMD_GEN_D5: 
 0F2  0B02C                                FETCH s0, 2C[CLI_WORD_1]
 0F3  2D0E0                                OUTPUT s0, E0[C5_data]
 0F4  25000                                RETURN 
 0F5                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_H.psm"["cmds_H.psm"]
 0F5                                       ;;; ============================================================================
 0F5                                       ;;; Register map
 0F5                                       ;;; ============================================================================
 0F5                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 0F5                                       ;;; | CMD_help   | x  | x  |    |    |    |    |    |    |    |    | x  |  x |
 0F5                                       ;;; ============================================================================
 0F5                                       ;;; Print Help functions
 0F5                                       ;; uses sA-sB, s1
 0F5                                       ;;; ============================================================================
 0F5                             CMD_help: 
 0F5  01B02                                LOAD sB, 02[cmds'upper]
 0F6  01A0A                                LOAD sA, 0A[cmds'lower]
 0F7                        CMD_help_loop: 
 0F7                                       ;; loop over commands
 0F7  24BA0                                CALL@ (sB, sA)                                   ; load next CMDs char into s1
 0F8  1D100                                COMPARE s1, 00                                   ; check for end of command
 0F9  32101                                JUMP Z, 101[CMD_help_eol]
 0FA  1D1FF                                COMPARE s1, FF                                   ; check for no more commands
 0FB  32105                                JUMP Z, 105[CMD_help_end]
 0FC  20002                                CALL 002[uart_output_wait]
 0FD  2D101                                OUTPUT s1, 01[UART_OUTPUT]                       ; print char
 0FE  11A01                                ADD sA, 01                                       ; move forward
 0FF  13B00                                ADDCY sB, 00
 100  220F7                                JUMP 0F7[CMD_help_loop]
 101                         CMD_help_eol: 
 101  20059                                CALL 059[util_print_EOL]                         ; print EOL
 102  11A03                                ADD sA, 03                                       ; move forwardpast the function address
 103  13B00                                ADDCY sB, 00
 104  220F7                                JUMP 0F7[CMD_help_loop]
 105                         CMD_help_end: 
 105  20059                                CALL 059[util_print_EOL]
 106  25000                                RETURN 
 107                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_M.psm"["cmds_M.psm"]
 107                                       ;;; ============================================================================
 107                                       ;;; Register map
 107                                       ;;; ============================================================================
 107                                       ;;; | name         | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 107                                       ;;; | CMD_Mem_dump | x  | x  | x  | x  |    |    |    |    |    |    | x  |  x |
 107                                       ;;; | CMD_multiarg | x  | x  | x  | x  | x  | x  | x  |    |    |    | x  |  x |
 107                                       ;;; DUMP data to user
 107                                       ;; 1) write size of data in memory
 107                                       ;; 2) Write data
 107                                       ;; 3) Write CMD_DUMP
 107                                       ;;; ============================================================================
 107                         CMD_Mem_dump: 
 107  01300                                LOAD s3, 00                                      ; initialize read pointer
 108                    CMD_Mem_dump_loop: 
 108                                       ;; print offset
 108  00030                                LOAD s0, s3
 109  20041                                CALL 041[util_byte_to_hex]
 10A  20002                                CALL 002[uart_output_wait]
 10B  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 10C  20002                                CALL 002[uart_output_wait]
 10D  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 10E                                       ;; print ": "
 10E  20002                                CALL 002[uart_output_wait]
 10F  0103A                                LOAD s0, 3A[":"]
 110  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 111  20002                                CALL 002[uart_output_wait]
 112  01020                                LOAD s0, 20[" "]
 113  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 114                                       ;; print 4 bytes of data
 114               CMD_Mem_dump_line_loop: 
 114  0A030                                FETCH s0, (s3)                                   ; fetch data
 115  20041                                CALL 041[util_byte_to_hex]
 116  20002                                CALL 002[uart_output_wait]
 117  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 118  20002                                CALL 002[uart_output_wait]
 119  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 11A                                       ;; check for end of the buffer
 11A  1D3FF                                COMPARE s3, FF[MEM_SIZE]                         ; see if we are past valid memory
 11B  32123                                JUMP Z, 123[CMD_Mem_dump_end]
 11C                                       ;; backup last printed pointer
 11C  00030                                LOAD s0, s3
 11D  11301                                ADD s3, 01                                       ;move forward in pointer
 11E                                       ;; determine if we are at the 4 byte line boundary
 11E  03003                                AND s0, 03
 11F  1D003                                COMPARE s0, 03
 120  36114                                JUMP NZ, 114[CMD_Mem_dump_line_loop]
 121                                       ;; print EOL after 4 bytes
 121  20059                                CALL 059[util_print_EOL]
 122  22108                                JUMP 108[CMD_Mem_dump_loop]
 123                     CMD_Mem_dump_end: 
 123  20059                                CALL 059[util_print_EOL]
 124  25000                                RETURN 
 125                         CMD_multiarg: 
 125  2017E                                CALL 17E[CMD_sys]
 126  0B023                                FETCH s0, 23[CLI_COUNT]                          ; load the already parsed commands
 127  1D004                                COMPARE s0, 04                                   ; jump to the end if we have fewer than 4 args
 128  3A12F                                JUMP C, 12F[CMD_multiarg_end]
 129                                       ;; reparse the reset of the args
 129                                       ;; get CMD4's postions
 129  0B227                                FETCH s2, 27[CLI_WORD_4_POS]
 12A                                       ;; get CMD4's size
 12A  0B12B                                FETCH s1, 2B[CLI_WORD_4_SIZE]
 12B  10210                                ADD s2, s1
 12C                                       ;; computer new end pos
 12C  202AC                                CALL 2AC[cmd_tokenize]
 12D  202FB                                CALL 2FB[cmd_parse_tokens]
 12E  2017E                                CALL 17E[CMD_sys]
 12F                     CMD_multiarg_end: 
 12F  25000                                RETURN 
 130                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_P.psm"["cmds_P.psm"]
 130                                       ;;; ============================================================================
 130                                       ;;; Register map
 130                                       ;;; ============================================================================
 130                                       ;;; | name             | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 130                                       ;;; | CMD_period       | x  | x  |    |    | x  |    |    |    |    |    |    |    |
 130                                       ;;; | CMD_pulse_period | x  | x  |    |    | x  |    |    |    |    |    |    |    |
 130                           CMD_period: 
 130  01440                                LOAD s4, 40                                      ;store address
 131  0112C                                LOAD s1, 2C[CLI_WORD_1]                          ;pointer
 132  0A010                                FETCH s0, (s1)                                   ;fetch lsb of channel period
 133  2C040                                OUTPUT s0, (s4)                                  ;output lsb
 134  11401                                ADD s4, 01                                       ;next byte of address
 135  11101                                ADD s1, 01                                       ;next byte of channel period
 136  0A010                                FETCH s0, (s1)
 137  2C040                                OUTPUT s0, (s4)                                  ;middle byte
 138  11401                                ADD s4, 01
 139  11101                                ADD s1, 01                                       ;msb
 13A  0A010                                FETCH s0, (s1)
 13B  2C040                                OUTPUT s0, (s4)                                  ;msb
 13C  25000                                RETURN 
 13D                     CMD_pulse_period: 
 13D  01444                                LOAD s4, 44                                      ;store address
 13E  0112C                                LOAD s1, 2C[CLI_WORD_1]                          ;pointer
 13F  0A010                                FETCH s0, (s1)                                   ;fetch lsb of channel period
 140  2C040                                OUTPUT s0, (s4)                                  ;output lsb
 141  11401                                ADD s4, 01                                       ;next byte of address
 142  11101                                ADD s1, 01                                       ;next byte of channel period
 143  0A010                                FETCH s0, (s1)
 144  2C040                                OUTPUT s0, (s4)                                  ;middle byte
 145  11401                                ADD s4, 01
 146  11101                                ADD s1, 01                                       ;msb
 147  0A010                                FETCH s0, (s1)
 148  2C040                                OUTPUT s0, (s4)                                  ;msb
 149  25000                                RETURN 
 14A                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_R.psm"["cmds_R.psm"]
 14A                                       ;;; ============================================================================
 14A                                       ;;; Register map
 14A                                       ;;; ============================================================================
 14A                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 14A                                       ;;; | CMD_reset  | x  | x  | x  |    |    |    |    |    |    |    | x  |  x |
 14A                                       ;;; ============================================================================
 14A                                       ;;; Reset UI
 14A                                       ;;; ============================================================================
 14A                            CMD_reset: 
 14A  2008F                                CALL 08F[hard_reset]
 14B  25000                                RETURN 
 14C                         CMD_rapid_on: 
 14C  010FF                                LOAD s0, FF
 14D  2D009                                OUTPUT s0, 09[ONCEPORT]
 14E  25000                                RETURN 
 14F                        CMD_rapid_off: 
 14F  01000                                LOAD s0, 00
 150  2D009                                OUTPUT s0, 09[ONCEPORT]
 151  25000                                RETURN 
 152                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_S.psm"["cmds_S.psm"]
 152                                       ;;; ============================================================================
 152                                       ;;; Register map
 152                                       ;;; ============================================================================
 152                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 152                                       ;;; | CMD_sys    | x  | x  | x  | x  | x  | x  | x  |    |    |    | x  |  x |
 152                                       STRING BUFFER$, "Buffer: "
 152                                       STRING WORD_COUNT$, "Word count: "
 152                                       STRING WORD_SIZE$, "Word sizes:    "
 152                                       STRING WORD$, "Word "
 152                           str_BUFFER: 
 152  21142                                LOAD&RETURN s1, 42[BUFFER$:"B"]
 153  21175                                LOAD&RETURN s1, 75[BUFFER$:"u"]
 154  21166                                LOAD&RETURN s1, 66[BUFFER$:"f"]
 155  21166                                LOAD&RETURN s1, 66[BUFFER$:"f"]
 156  21165                                LOAD&RETURN s1, 65[BUFFER$:"e"]
 157  21172                                LOAD&RETURN s1, 72[BUFFER$:"r"]
 158  2113A                                LOAD&RETURN s1, 3A[BUFFER$:":"]
 159  21120                                LOAD&RETURN s1, 20[BUFFER$:" "]
 15A  21100                                LOAD&RETURN s1, 00
 15B                       str_WORD_COUNT: 
 15B  21157                                LOAD&RETURN s1, 57[WORD_COUNT$:"W"]
 15C  2116F                                LOAD&RETURN s1, 6F[WORD_COUNT$:"o"]
 15D  21172                                LOAD&RETURN s1, 72[WORD_COUNT$:"r"]
 15E  21164                                LOAD&RETURN s1, 64[WORD_COUNT$:"d"]
 15F  21120                                LOAD&RETURN s1, 20[WORD_COUNT$:" "]
 160  21163                                LOAD&RETURN s1, 63[WORD_COUNT$:"c"]
 161  2116F                                LOAD&RETURN s1, 6F[WORD_COUNT$:"o"]
 162  21175                                LOAD&RETURN s1, 75[WORD_COUNT$:"u"]
 163  2116E                                LOAD&RETURN s1, 6E[WORD_COUNT$:"n"]
 164  21174                                LOAD&RETURN s1, 74[WORD_COUNT$:"t"]
 165  2113A                                LOAD&RETURN s1, 3A[WORD_COUNT$:":"]
 166  21120                                LOAD&RETURN s1, 20[WORD_COUNT$:" "]
 167  21100                                LOAD&RETURN s1, 00
 168                        str_WORD_SIZE: 
 168  21157                                LOAD&RETURN s1, 57[WORD_SIZE$:"W"]
 169  2116F                                LOAD&RETURN s1, 6F[WORD_SIZE$:"o"]
 16A  21172                                LOAD&RETURN s1, 72[WORD_SIZE$:"r"]
 16B  21164                                LOAD&RETURN s1, 64[WORD_SIZE$:"d"]
 16C  21120                                LOAD&RETURN s1, 20[WORD_SIZE$:" "]
 16D  21173                                LOAD&RETURN s1, 73[WORD_SIZE$:"s"]
 16E  21169                                LOAD&RETURN s1, 69[WORD_SIZE$:"i"]
 16F  2117A                                LOAD&RETURN s1, 7A[WORD_SIZE$:"z"]
 170  21165                                LOAD&RETURN s1, 65[WORD_SIZE$:"e"]
 171  21173                                LOAD&RETURN s1, 73[WORD_SIZE$:"s"]
 172  2113A                                LOAD&RETURN s1, 3A[WORD_SIZE$:":"]
 173  21120                                LOAD&RETURN s1, 20[WORD_SIZE$:" "]
 174  21120                                LOAD&RETURN s1, 20[WORD_SIZE$:" "]
 175  21120                                LOAD&RETURN s1, 20[WORD_SIZE$:" "]
 176  21120                                LOAD&RETURN s1, 20[WORD_SIZE$:" "]
 177  21100                                LOAD&RETURN s1, 00
 178                             str_WORD: 
 178  21157                                LOAD&RETURN s1, 57[WORD$:"W"]
 179  2116F                                LOAD&RETURN s1, 6F[WORD$:"o"]
 17A  21172                                LOAD&RETURN s1, 72[WORD$:"r"]
 17B  21164                                LOAD&RETURN s1, 64[WORD$:"d"]
 17C  21120                                LOAD&RETURN s1, 20[WORD$:" "]
 17D  21100                                LOAD&RETURN s1, 00
 17E                                       ;;; ============================================================================
 17E                                       ;;; Prints system area of scratchpad to the screen for debugging
 17E                                       ;; uses sA,sB,s0,s1,s2,s3,s4,s5,s6
 17E                                       ;;; ============================================================================
 17E                              CMD_sys: 
 17E                                       ;; print CLI buffer
 17E  01B01                                LOAD sB, 01[str_BUFFER'upper]
 17F  01A52                                LOAD sA, 52[str_BUFFER'lower]
 180  20064                                CALL 064[util_print_string]
 181                                       ;; load values from buffer to print
 181  01100                                LOAD s1, 00[CLI_BUFFER_START]
 182  0B220                                FETCH s2, 20[CLI_BUFFER]
 183                       CMD_sys_buffer: 
 183  1C120                                COMPARE s1, s2
 184  3E18A                                JUMP NC, 18A[CMD_sys_buffer_size]                ;when we are done with the buffer, jump to word count
 185  20002                                CALL 002[uart_output_wait]
 186  0A010                                FETCH s0, (s1)
 187  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 188  11101                                ADD s1, 01
 189  22183                                JUMP 183[CMD_sys_buffer]
 18A                  CMD_sys_buffer_size: 
 18A  20002                                CALL 002[uart_output_wait]
 18B  01020                                LOAD s0, 20[" "]
 18C  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 18D  20002                                CALL 002[uart_output_wait]
 18E  01028                                LOAD s0, 28["("]
 18F  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 190  00020                                LOAD s0, s2
 191  20041                                CALL 041[util_byte_to_hex]
 192  20002                                CALL 002[uart_output_wait]
 193  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 194  20002                                CALL 002[uart_output_wait]
 195  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 196  20002                                CALL 002[uart_output_wait]
 197  01029                                LOAD s0, 29[")"]
 198  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 199  20059                                CALL 059[util_print_EOL]
 19A                   CMD_sys_word_count: 
 19A                                       ;; print word count
 19A  01B01                                LOAD sB, 01[str_WORD_COUNT'upper]
 19B  01A5B                                LOAD sA, 5B[str_WORD_COUNT'lower]
 19C  20064                                CALL 064[util_print_string]
 19D  20002                                CALL 002[uart_output_wait]
 19E  0B023                                FETCH s0, 23[CLI_COUNT]
 19F  20041                                CALL 041[util_byte_to_hex]
 1A0  20002                                CALL 002[uart_output_wait]
 1A1  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 1A2  20002                                CALL 002[uart_output_wait]
 1A3  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 1A4  0B423                                FETCH s4, 23[CLI_COUNT]
 1A5  01300                                LOAD s3, 00
 1A6                     CMD_sys_word_pos: 
 1A6  1C340                                COMPARE s3, s4
 1A7  3E1B8                                JUMP NC, 1B8[CMD_sys_word_size]
 1A8  20002                                CALL 002[uart_output_wait]
 1A9  01020                                LOAD s0, 20[" "]
 1AA  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 1AB  20002                                CALL 002[uart_output_wait]
 1AC  01040                                LOAD s0, 40["@"]
 1AD  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 1AE  01124                                LOAD s1, 24[CLI_WORD_1_POS]
 1AF  10130                                ADD s1, s3
 1B0  0A010                                FETCH s0, (s1)
 1B1  20041                                CALL 041[util_byte_to_hex]
 1B2  20002                                CALL 002[uart_output_wait]
 1B3  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 1B4  20002                                CALL 002[uart_output_wait]
 1B5  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 1B6  11301                                ADD s3, 01
 1B7  221A6                                JUMP 1A6[CMD_sys_word_pos]
 1B8                    CMD_sys_word_size: 
 1B8  20059                                CALL 059[util_print_EOL]
 1B9                                       ;; print word size
 1B9  01B01                                LOAD sB, 01[str_WORD_SIZE'upper]
 1BA  01A68                                LOAD sA, 68[str_WORD_SIZE'lower]
 1BB  20064                                CALL 064[util_print_string]
 1BC  0B423                                FETCH s4, 23[CLI_COUNT]
 1BD  01300                                LOAD s3, 00
 1BE               CMD_sys_word_size_loop: 
 1BE  1C340                                COMPARE s3, s4
 1BF  3E1CD                                JUMP NC, 1CD[CMD_sys_word]
 1C0  20002                                CALL 002[uart_output_wait]
 1C1  01020                                LOAD s0, 20[" "]
 1C2  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 1C3  01128                                LOAD s1, 28[CLI_WORD_1_SIZE]
 1C4  10130                                ADD s1, s3
 1C5  0A010                                FETCH s0, (s1)
 1C6  20041                                CALL 041[util_byte_to_hex]
 1C7  20002                                CALL 002[uart_output_wait]
 1C8  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 1C9  20002                                CALL 002[uart_output_wait]
 1CA  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 1CB  11301                                ADD s3, 01
 1CC  221BE                                JUMP 1BE[CMD_sys_word_size_loop]
 1CD                         CMD_sys_word: 
 1CD  20059                                CALL 059[util_print_EOL]
 1CE  0B423                                FETCH s4, 23[CLI_COUNT]
 1CF  01300                                LOAD s3, 00
 1D0                    CMD_sys_word_loop: 
 1D0  1C340                                COMPARE s3, s4
 1D1  3E1F0                                JUMP NC, 1F0[CMD_sys_word_end]
 1D2                                       ;; print word size
 1D2  20059                                CALL 059[util_print_EOL]
 1D3  01B01                                LOAD sB, 01[str_WORD'upper]
 1D4  01A78                                LOAD sA, 78[str_WORD'lower]
 1D5  20064                                CALL 064[util_print_string]
 1D6  00030                                LOAD s0, s3
 1D7  20041                                CALL 041[util_byte_to_hex]
 1D8  20002                                CALL 002[uart_output_wait]
 1D9  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 1DA  20002                                CALL 002[uart_output_wait]
 1DB  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 1DC  20002                                CALL 002[uart_output_wait]
 1DD  01020                                LOAD s0, 20[" "]
 1DE  2D001                                OUTPUT s0, 01[UART_OUTPUT]
 1DF                                       ;; go to the offset for this word
 1DF  00530                                LOAD s5, s3
 1E0  11301                                ADD s3, 01
 1E1  14506                                SL0 s5
 1E2  14506                                SL0 s5
 1E3  1152C                                ADD s5, 2C[CLI_WORD_1]
 1E4  00650                                LOAD s6, s5
 1E5  11603                                ADD s6, 03
 1E6         CMD_sys_word_loop_print_loop: 
 1E6  1C650                                COMPARE s6, s5
 1E7  3A1D0                                JUMP C, 1D0[CMD_sys_word_loop]
 1E8  0A060                                FETCH s0, (s6)
 1E9  20041                                CALL 041[util_byte_to_hex]
 1EA  20002                                CALL 002[uart_output_wait]
 1EB  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 1EC  20002                                CALL 002[uart_output_wait]
 1ED  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 1EE  19601                                SUB s6, 01
 1EF  221E6                                JUMP 1E6[CMD_sys_word_loop_print_loop]
 1F0                     CMD_sys_word_end: 
 1F0  20059                                CALL 059[util_print_EOL]
 1F1  25000                                RETURN 
 1F2                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_T.psm"["cmds_T.psm"]
 1F2                                       ;;; ============================================================================
 1F2                                       ;;; Register map
 1F2                                       ;;; ============================================================================
 1F2                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 1F2                                       ;;; | cmds       |    | x  |    |    |    |    |    |    |    |    |    |    |
 1F2                     CMD_TDC_loopback: 
 1F2  0B02C                                FETCH s0, 2C[CLI_WORD_1]
 1F3  2D020                                OUTPUT s0, 20[CTRL_port]
 1F4  25000                                RETURN 
 1F5                                       INCLUDE "Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_V.psm"["cmds_V.psm"]
 1F5                                       ;;; ============================================================================
 1F5                                       ;;; Register map
 1F5                                       ;;; ============================================================================
 1F5                                       ;;; | name       | s0 | s1 | s2 | s3 | s4 | s5 | s6 | s7 | s8 | s9 | sA | sB |
 1F5                                       ;;; | hard_reset | x  | x  | x  |    |    |    |    |    |    |    | x  |  x |
 1F5                                       ;;; ============================================================================
 1F5                                       ;;; Prints "Ver: #" to UART
 1F5                                       ;; molests s0-s2
 1F5                                       ;;; ============================================================================
 1F5                                       STRING ver$, "Version: "
 1F5                              str_ver: 
 1F5  21156                                LOAD&RETURN s1, 56[ver$:"V"]
 1F6  21165                                LOAD&RETURN s1, 65[ver$:"e"]
 1F7  21172                                LOAD&RETURN s1, 72[ver$:"r"]
 1F8  21173                                LOAD&RETURN s1, 73[ver$:"s"]
 1F9  21169                                LOAD&RETURN s1, 69[ver$:"i"]
 1FA  2116F                                LOAD&RETURN s1, 6F[ver$:"o"]
 1FB  2116E                                LOAD&RETURN s1, 6E[ver$:"n"]
 1FC  2113A                                LOAD&RETURN s1, 3A[ver$:":"]
 1FD  21120                                LOAD&RETURN s1, 20[ver$:" "]
 1FE  21100                                LOAD&RETURN s1, 00
 1FF                          CMD_version: 
 1FF  01B01                                LOAD sB, 01[str_ver'upper]
 200  01AF5                                LOAD sA, F5[str_ver'lower]
 201  20064                                CALL 064[util_print_string]
 202  01001                                LOAD s0, 01[UI_VERSION]
 203  20041                                CALL 041[util_byte_to_hex]
 204  20002                                CALL 002[uart_output_wait]
 205  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 206  20002                                CALL 002[uart_output_wait]
 207  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 208  20059                                CALL 059[util_print_EOL]
 209  25000                                RETURN 
 20A                                       STRING multiarg$, "multiarg"
 20A                                       STRING memdump$, "memdump"
 20A                                       STRING reset$, "reset"
 20A                                       STRING version$, "version"
 20A                                       STRING sys$, "sys"
 20A                                       STRING help$, "help"
 20A                                       STRING dac$, "d"
 20A                                       STRING channel$, "c"
 20A                                       STRING fire$, "s"
 20A                                       STRING rapid_on$, "n"
 20A                                       STRING rapid_off$, "m"
 20A                                       ;; STRING pulse_help msg$, "h"
 20A                                       STRING cont_start$, "a"
 20A                                       STRING cont_stop$, "z"
 20A                                       STRING period$, "p"
 20A                                       STRING pulse_period$, "t"
 20A                                       STRING GEN_C5$, "CC"
 20A                                       STRING GEN_D5$, "CD"
 20A                                       STRING FIFO_flags$, "F"
 20A                                       STRING FIFO_read$, "D"
 20A                                       STRING FIFO_reset$, "R"
 20A                                       STRING TDC_loopback$, "M"
 20A                                 cmds: 
 20A                                       ;; CMD_multiarg (multiarg)
 20A  2116D                                LOAD&RETURN s1, 6D[multiarg$:"m"]
 20B  21175                                LOAD&RETURN s1, 75[multiarg$:"u"]
 20C  2116C                                LOAD&RETURN s1, 6C[multiarg$:"l"]
 20D  21174                                LOAD&RETURN s1, 74[multiarg$:"t"]
 20E  21169                                LOAD&RETURN s1, 69[multiarg$:"i"]
 20F  21161                                LOAD&RETURN s1, 61[multiarg$:"a"]
 210  21172                                LOAD&RETURN s1, 72[multiarg$:"r"]
 211  21167                                LOAD&RETURN s1, 67[multiarg$:"g"]
 212  21100                                LOAD&RETURN s1, 00                               ; end of command
 213  21101                                LOAD&RETURN s1, 01[CMD_multiarg'upper]
 214  21125                                LOAD&RETURN s1, 25[CMD_multiarg'lower]
 215                                       ;; CMD_Mem_dump (memdump)
 215  2116D                                LOAD&RETURN s1, 6D[memdump$:"m"]
 216  21165                                LOAD&RETURN s1, 65[memdump$:"e"]
 217  2116D                                LOAD&RETURN s1, 6D[memdump$:"m"]
 218  21164                                LOAD&RETURN s1, 64[memdump$:"d"]
 219  21175                                LOAD&RETURN s1, 75[memdump$:"u"]
 21A  2116D                                LOAD&RETURN s1, 6D[memdump$:"m"]
 21B  21170                                LOAD&RETURN s1, 70[memdump$:"p"]
 21C  21100                                LOAD&RETURN s1, 00                               ; end of command
 21D  21101                                LOAD&RETURN s1, 01[CMD_Mem_dump'upper]
 21E  21107                                LOAD&RETURN s1, 07[CMD_Mem_dump'lower]
 21F                                       ;; CMD_reset (reset)
 21F  21172                                LOAD&RETURN s1, 72[reset$:"r"]
 220  21165                                LOAD&RETURN s1, 65[reset$:"e"]
 221  21173                                LOAD&RETURN s1, 73[reset$:"s"]
 222  21165                                LOAD&RETURN s1, 65[reset$:"e"]
 223  21174                                LOAD&RETURN s1, 74[reset$:"t"]
 224  21100                                LOAD&RETURN s1, 00                               ; end of command
 225  21101                                LOAD&RETURN s1, 01[CMD_reset'upper]
 226  2114A                                LOAD&RETURN s1, 4A[CMD_reset'lower]
 227                                       ;; CMD_Version (version)
 227  21176                                LOAD&RETURN s1, 76[version$:"v"]
 228  21165                                LOAD&RETURN s1, 65[version$:"e"]
 229  21172                                LOAD&RETURN s1, 72[version$:"r"]
 22A  21173                                LOAD&RETURN s1, 73[version$:"s"]
 22B  21169                                LOAD&RETURN s1, 69[version$:"i"]
 22C  2116F                                LOAD&RETURN s1, 6F[version$:"o"]
 22D  2116E                                LOAD&RETURN s1, 6E[version$:"n"]
 22E  21100                                LOAD&RETURN s1, 00                               ; end of command
 22F  21101                                LOAD&RETURN s1, 01[CMD_version'upper]
 230  211FF                                LOAD&RETURN s1, FF[CMD_version'lower]
 231                                       ;; CMD_sys (sys)
 231  21173                                LOAD&RETURN s1, 73[sys$:"s"]
 232  21179                                LOAD&RETURN s1, 79[sys$:"y"]
 233  21173                                LOAD&RETURN s1, 73[sys$:"s"]
 234  21100                                LOAD&RETURN s1, 00                               ; end of command
 235  21101                                LOAD&RETURN s1, 01[CMD_sys'upper]
 236  2117E                                LOAD&RETURN s1, 7E[CMD_sys'lower]
 237                                       ;; CMD_help (help)
 237  21168                                LOAD&RETURN s1, 68[help$:"h"]
 238  21165                                LOAD&RETURN s1, 65[help$:"e"]
 239  2116C                                LOAD&RETURN s1, 6C[help$:"l"]
 23A  21170                                LOAD&RETURN s1, 70[help$:"p"]
 23B  21100                                LOAD&RETURN s1, 00                               ; end of command
 23C  21100                                LOAD&RETURN s1, 00[CMD_help'upper]
 23D  211F5                                LOAD&RETURN s1, F5[CMD_help'lower]
 23E                                       ;; CMD_dac
 23E  21164                                LOAD&RETURN s1, 64[dac$:"d"]
 23F  21100                                LOAD&RETURN s1, 00                               ; end of command
 240  21100                                LOAD&RETURN s1, 00[CMD_dac'upper]
 241  211B9                                LOAD&RETURN s1, B9[CMD_dac'lower]
 242                                       ;; CMD_channel
 242  21163                                LOAD&RETURN s1, 63[channel$:"c"]
 243  21100                                LOAD&RETURN s1, 00                               ; end of command
 244  21100                                LOAD&RETURN s1, 00[CMD_channel'upper]
 245  211A2                                LOAD&RETURN s1, A2[CMD_channel'lower]
 246                                       ;; CMD_fire
 246  21173                                LOAD&RETURN s1, 73[fire$:"s"]
 247  21100                                LOAD&RETURN s1, 00                               ; end of command
 248  21100                                LOAD&RETURN s1, 00[CMD_fire'upper]
 249  211BF                                LOAD&RETURN s1, BF[CMD_fire'lower]
 24A                                       ;; CMD_rapid_on
 24A  2116E                                LOAD&RETURN s1, 6E[rapid_on$:"n"]
 24B  21100                                LOAD&RETURN s1, 00                               ; end of command
 24C  21101                                LOAD&RETURN s1, 01[CMD_rapid_on'upper]
 24D  2114C                                LOAD&RETURN s1, 4C[CMD_rapid_on'lower]
 24E                                       ;; CMD_rapid_off
 24E  2116D                                LOAD&RETURN s1, 6D[rapid_off$:"m"]
 24F  21100                                LOAD&RETURN s1, 00                               ; end of command
 250  21101                                LOAD&RETURN s1, 01[CMD_rapid_off'upper]
 251  2114F                                LOAD&RETURN s1, 4F[CMD_rapid_off'lower]
 252                                       ;; CMD_cont_start
 252  21161                                LOAD&RETURN s1, 61[cont_start$:"a"]
 253  21100                                LOAD&RETURN s1, 00                               ; end of command
 254  21100                                LOAD&RETURN s1, 00[CMD_cont_start'upper]
 255  211B3                                LOAD&RETURN s1, B3[CMD_cont_start'lower]
 256                                       ;; CMD_cont_stop
 256  2117A                                LOAD&RETURN s1, 7A[cont_stop$:"z"]
 257  21100                                LOAD&RETURN s1, 00                               ; end of command
 258  21100                                LOAD&RETURN s1, 00[CMD_cont_stop'upper]
 259  211B6                                LOAD&RETURN s1, B6[CMD_cont_stop'lower]
 25A                                       ;; CMD_period
 25A  21170                                LOAD&RETURN s1, 70[period$:"p"]
 25B  21100                                LOAD&RETURN s1, 00                               ; end of command
 25C  21101                                LOAD&RETURN s1, 01[CMD_period'upper]
 25D  21130                                LOAD&RETURN s1, 30[CMD_period'lower]
 25E                                       ;; CMD_pulse_period
 25E  21174                                LOAD&RETURN s1, 74[pulse_period$:"t"]
 25F  21100                                LOAD&RETURN s1, 00                               ; end of command
 260  21101                                LOAD&RETURN s1, 01[CMD_pulse_period'upper]
 261  2113D                                LOAD&RETURN s1, 3D[CMD_pulse_period'lower]
 262                                       ;; CMD_GEN_C5
 262  21143                                LOAD&RETURN s1, 43[GEN_C5$:"C"]
 263  21143                                LOAD&RETURN s1, 43[GEN_C5$:"C"]
 264  21100                                LOAD&RETURN s1, 00                               ; end of command
 265  21100                                LOAD&RETURN s1, 00[CMD_GEN_C5'upper]
 266  211EE                                LOAD&RETURN s1, EE[CMD_GEN_C5'lower]
 267                                       ;; CMD_GEN_D5
 267  21143                                LOAD&RETURN s1, 43[GEN_D5$:"C"]
 268  21144                                LOAD&RETURN s1, 44[GEN_D5$:"D"]
 269  21100                                LOAD&RETURN s1, 00                               ; end of command
 26A  21100                                LOAD&RETURN s1, 00[CMD_GEN_D5'upper]
 26B  211F2                                LOAD&RETURN s1, F2[CMD_GEN_D5'lower]
 26C                                       ;; CMD_FIFO_flags
 26C  21146                                LOAD&RETURN s1, 46[FIFO_flags$:"F"]
 26D  21100                                LOAD&RETURN s1, 00                               ; end of command
 26E  21100                                LOAD&RETURN s1, 00[CMD_FIFO_flags'upper]
 26F  211C4                                LOAD&RETURN s1, C4[CMD_FIFO_flags'lower]
 270                                       ;; CMD_FIFO_read
 270  21144                                LOAD&RETURN s1, 44[FIFO_read$:"D"]
 271  21100                                LOAD&RETURN s1, 00                               ; end of command
 272  21100                                LOAD&RETURN s1, 00[CMD_FIFO_read'upper]
 273  211C8                                LOAD&RETURN s1, C8[CMD_FIFO_read'lower]
 274                                       ;; CMD_FIFO_reset
 274  21152                                LOAD&RETURN s1, 52[FIFO_reset$:"R"]
 275  21100                                LOAD&RETURN s1, 00                               ; end of command
 276  21100                                LOAD&RETURN s1, 00[CMD_FIFO_reset'upper]
 277  211EA                                LOAD&RETURN s1, EA[CMD_FIFO_reset'lower]
 278                                       ;; CMD_TDC_loopback
 278  2114D                                LOAD&RETURN s1, 4D[TDC_loopback$:"M"]
 279  21100                                LOAD&RETURN s1, 00                               ; end of command
 27A  21101                                LOAD&RETURN s1, 01[CMD_TDC_loopback'upper]
 27B  211F2                                LOAD&RETURN s1, F2[CMD_TDC_loopback'lower]
 27C  211FF                                LOAD&RETURN s1, FF                               ; end of commands string
 27D                                       ;;; ============================================================================
 27D                                       ;;; Find function to call, parse arguemtns and then call it
 27D                                       ;;; ============================================================================
 27D                             cmd_find: 
 27D  01B02                                LOAD sB, 02[cmds'upper]
 27E  01A0A                                LOAD sA, 0A[cmds'lower]
 27F  01200                                LOAD s2, 00[CLI_BUFFER_START]
 280                        cmd_find_loop: 
 280                                       ;; process next cmds char
 280  24BA0                                CALL@ (sB, sA)                                   ; load next cmds char into s1
 281  1D100                                COMPARE s1, 00                                   ; check for end of command
 282  3229B                                JUMP Z, 29B[cmd_find_call]
 283  1D1FF                                COMPARE s1, FF                                   ; check for no more commands
 284  322A8                                JUMP Z, 2A8[cmd_find_failed]
 285                                       ;; process next CLI_BUFFER char
 285  0B020                                FETCH s0, 20[CLI_BUFFER]                         ; get the end of buffer ptr
 286  1C200                                COMPARE s2, s0                                   ; check for overflow
 287  3E28F                                JUMP NC, 28F[cmd_find_next]
 288                                       ;; compare cmd/buffer chars
 288  0A020                                FETCH s0, (s2)                                   ; fetch the buffer's char
 289  1C010                                COMPARE s0, s1                                   ; compare it to the current cmd
 28A  3628F                                JUMP NZ, 28F[cmd_find_next]                      ; move on to next command if not equal
 28B  11201                                ADD s2, 01                                       ; move on to next char if equal
 28C  11A01                                ADD sA, 01
 28D  13B00                                ADDCY sB, 00
 28E  22280                                JUMP 280[cmd_find_loop]
 28F                        cmd_find_next: 
 28F                                       ;; find the next command
 28F  24BA0                                CALL@ (sB, sA)                                   ; load next cmds char into s1
 290  1D1FF                                COMPARE s1, FF                                   ; check for no more commands
 291  322A8                                JUMP Z, 2A8[cmd_find_failed]
 292  1D100                                COMPARE s1, 00                                   ; check for end of command
 293  32297                                JUMP Z, 297[cmd_find_next_reset]
 294  11A01                                ADD sA, 01
 295  13B00                                ADDCY sB, 00
 296  2228F                                JUMP 28F[cmd_find_next]
 297                  cmd_find_next_reset: 
 297                                       ;; move to the start of the next command
 297  11A03                                ADD sA, 03
 298  13B00                                ADDCY sB, 00
 299                                       ;; reset CLI_BUFFER pointer
 299  01200                                LOAD s2, 00[CLI_BUFFER_START]
 29A  22280                                JUMP 280[cmd_find_loop]
 29B                        cmd_find_call: 
 29B                                       ;; call tokenizer
 29B  202AC                                CALL 2AC[cmd_tokenize]
 29C  202FB                                CALL 2FB[cmd_parse_tokens]
 29D                                       ;; get command we are suppose to call
 29D  11A01                                ADD sA, 01
 29E  13B00                                ADDCY sB, 00
 29F  24BA0                                CALL@ (sB, sA)
 2A0  00210                                LOAD s2, s1
 2A1  11A01                                ADD sA, 01
 2A2  13B00                                ADDCY sB, 00
 2A3  24BA0                                CALL@ (sB, sA)
 2A4                                       ;; call the actual command
 2A4  24210                                CALL@ (s2, s1)
 2A5                                       ;; get ready for new user commands
 2A5  2009E                                CALL 09E[soft_reset]
 2A6  20060                                CALL 060[util_print_prompt]
 2A7  25000                                RETURN 
 2A8                      cmd_find_failed: 
 2A8  2009E                                CALL 09E[soft_reset]
 2A9  202E3                                CALL 2E3[cmd_invalid]
 2AA  20060                                CALL 060[util_print_prompt]
 2AB  25000                                RETURN 
 2AC                                       ;;; ============================================================================
 2AC                                       ;;; Search through string for 4 sequences of hex data
 2AC                                       ;; seaches through CLI_BUFFER using s2 to start
 2AC                                       ;; this will reset CLI_COUNT,CLI_WORD_*_POS,CLI_WORD_*_SIZE,CLI_WORD_*
 2AC                                       ;; uses s0,s1,s2,s3
 2AC                                       ;;; ============================================================================
 2AC                         cmd_tokenize: 
 2AC                                       ;; initialize CLI_COUNT to zero
 2AC  01000                                LOAD s0, 00
 2AD  2F023                                STORE s0, 23[CLI_COUNT]
 2AE                    cmd_tokenize_loop: 
 2AE                                       ;; search through the buffer for hex data
 2AE  0B120                                FETCH s1, 20[CLI_BUFFER]                         ; get end of valid buffer data
 2AF  1C210                                COMPARE s2, s1
 2B0  3E2D6                                JUMP NC, 2D6[cmd_tokenize_end]                   ; jump to the end if we run out of buffer
 2B1  0A020                                FETCH s0, (s2)                                   ; get next char
 2B2  11201                                ADD s2, 01                                       ; move forward in the buffer (for next time)
 2B3  2002F                                CALL 02F[util_char_to_nibble]                    ; check if currenc char is valid hex
 2B4  3E2AE                                JUMP NC, 2AE[cmd_tokenize_loop]                  ; non-ascii char, keep looking
 2B5  19201                                SUB s2, 01                                       ; move back in s2 since we want to be at the beginning of the hex string
 2B6                                       ;; found hex data. Update CLI_COUNT
 2B6  0B023                                FETCH s0, 23[CLI_COUNT]                          ; Get the number of words
 2B7  11001                                ADD s0, 01                                       ; Update the number of valid words
 2B8  1D005                                COMPARE s0, 05                                   ; check if we've reached our max
 2B9  322D6                                JUMP Z, 2D6[cmd_tokenize_end]                    ; end if we have
 2BA  2F023                                STORE s0, 23[CLI_COUNT]                          ; update CLI_COUNT
 2BB                                       ;; Start a new word by recording the position in CLI_WORD_*_POS
 2BB  01123                                LOAD s1, 23[CLI_COUNT]                           ; Load the CLI_COUNT address into s1
 2BC  10100                                ADD s1, s0                                       ; move forward in address by the current number of valid words (in s0)
 2BD  2E210                                STORE s2, (s1)                                   ; Write to this address the position of this word
 2BE  00320                                LOAD s3, s2                                      ; store the max position we an search to for valid hex
 2BF  11308                                ADD s3, 08                                       ; first assume that the hex string is 8 chars
 2C0  0B120                                FETCH s1, 20[CLI_BUFFER]                         ; now get the end of the buffer
 2C1  1C310                                COMPARE s3, s1                                   ; we have to make sure we don't walk off the buffer,
 2C2  3A2C4                                JUMP C, 2C4[cmd_tokenize_size]                   ; so compare the 8 char assumption to the buffer size
 2C3  00310                                LOAD s3, s1                                      ; and truncate if needed
 2C4                    cmd_tokenize_size: 
 2C4                                       ;; count number of hex digits (nibbles) in this word
 2C4  1C320                                COMPARE s3, s2                                   ; check if we've gone too far
 2C5  322CB                                JUMP Z, 2CB[cmd_tokenize_size_end]
 2C6  0A020                                FETCH s0, (s2)
 2C7  2002F                                CALL 02F[util_char_to_nibble]                    ; check if currenc char is valid hex
 2C8  3E2CB                                JUMP NC, 2CB[cmd_tokenize_size_end]              ; non-ascii char, go search for the next word
 2C9  11201                                ADD s2, 01                                       ; move forward in the string
 2CA  222C4                                JUMP 2C4[cmd_tokenize_size]
 2CB                cmd_tokenize_size_end: 
 2CB                                       ;; store the size of this word's data
 2CB  00320                                LOAD s3, s2                                      ; store our current position in s3
 2CC  0B123                                FETCH s1, 23[CLI_COUNT]                          ; Load the count number to let us fetch this word's start position
 2CD  11124                                ADD s1, 24[CLI_WORD_1_POS]                       ; Add the count to CLI_WORD_1_POS
 2CE  19101                                SUB s1, 01                                       ; move back one because count = 1 puts us in work 2 pos
 2CF  0A010                                FETCH s0, (s1)                                   ; fetch the start pointer for this word
 2D0  18300                                SUB s3, s0                                       ; computer the number of nibbles for this word
 2D1  0B023                                FETCH s0, 23[CLI_COUNT]                          ; computer the position of the current word's
 2D2  11028                                ADD s0, 28[CLI_WORD_1_SIZE]                      ; add the size 1 address
 2D3  19001                                SUB s0, 01                                       ; remove 1 because count starts at 1
 2D4  2E300                                STORE s3, (s0)                                   ; store the current word's size
 2D5  222AE                                JUMP 2AE[cmd_tokenize_loop]
 2D6                     cmd_tokenize_end: 
 2D6  25000                                RETURN 
 2D7                                       ;;; ============================================================================
 2D7                                       ;;; Prints "Bad command" to UART
 2D7                                       ;; uses s0-s1,sA-sB
 2D7                                       ;;; ============================================================================
 2D7                                       STRING BadCommand$, "Bad command"                ; string data
 2D7                       str_BadCommand: ; string function
 2D7  21142                                LOAD&RETURN s1, 42[BadCommand$:"B"]
 2D8  21161                                LOAD&RETURN s1, 61[BadCommand$:"a"]
 2D9  21164                                LOAD&RETURN s1, 64[BadCommand$:"d"]
 2DA  21120                                LOAD&RETURN s1, 20[BadCommand$:" "]
 2DB  21163                                LOAD&RETURN s1, 63[BadCommand$:"c"]
 2DC  2116F                                LOAD&RETURN s1, 6F[BadCommand$:"o"]
 2DD  2116D                                LOAD&RETURN s1, 6D[BadCommand$:"m"]
 2DE  2116D                                LOAD&RETURN s1, 6D[BadCommand$:"m"]
 2DF  21161                                LOAD&RETURN s1, 61[BadCommand$:"a"]
 2E0  2116E                                LOAD&RETURN s1, 6E[BadCommand$:"n"]
 2E1  21164                                LOAD&RETURN s1, 64[BadCommand$:"d"]
 2E2  21100                                LOAD&RETURN s1, 00
 2E3                          cmd_invalid: 
 2E3  01B02                                LOAD sB, 02[str_BadCommand'upper]                ; Load sB,sA to str function address
 2E4  01AD7                                LOAD sA, D7[str_BadCommand'lower]
 2E5  20064                                CALL 064[util_print_string]
 2E6  20059                                CALL 059[util_print_EOL]
 2E7  25000                                RETURN 
 2E8                                       ;;; ============================================================================
 2E8                                       ;;; Prints "Error s2" to UART
 2E8                                       ;; molests s0-s2,sA-sB
 2E8                                       ;;; EXTRA FUNCTIONALITY
 2E8                                       ;; if you want to quickly end a cmd_"subroutine" which has been
 2E8                                       ;; called using CALL, JUMP to this code instead.
 2E8                                       ;;; ============================================================================
 2E8                                       STRING Error$, "Error: "
 2E8                            str_Error: 
 2E8  21145                                LOAD&RETURN s1, 45[Error$:"E"]
 2E9  21172                                LOAD&RETURN s1, 72[Error$:"r"]
 2EA  21172                                LOAD&RETURN s1, 72[Error$:"r"]
 2EB  2116F                                LOAD&RETURN s1, 6F[Error$:"o"]
 2EC  21172                                LOAD&RETURN s1, 72[Error$:"r"]
 2ED  2113A                                LOAD&RETURN s1, 3A[Error$:":"]
 2EE  21120                                LOAD&RETURN s1, 20[Error$:" "]
 2EF  21100                                LOAD&RETURN s1, 00
 2F0                            cmd_error: 
 2F0  01B02                                LOAD sB, 02[str_Error'upper]                     ; Load sB,sA to str function address
 2F1  01AE8                                LOAD sA, E8[str_Error'lower]
 2F2  20064                                CALL 064[util_print_string]
 2F3                                       ;; convert s2 into hex and print it as an error number
 2F3  00020                                LOAD s0, s2
 2F4  20041                                CALL 041[util_byte_to_hex]
 2F5  20002                                CALL 002[uart_output_wait]
 2F6  2D201                                OUTPUT s2, 01[UART_OUTPUT]
 2F7  20002                                CALL 002[uart_output_wait]
 2F8  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 2F9  20059                                CALL 059[util_print_EOL]
 2FA  25000                                RETURN 
 2FB                                       ;;; ============================================================================
 2FB                                       ;;; Parses the data at the tokens and puts them in CLI_WORD_*
 2FB                                       ;;; ============================================================================
 2FB                     cmd_parse_tokens: 
 2FB  01238                                LOAD s2, 38[CLI_WORD_4]
 2FC  11204                                ADD s2, 04                                       ;load end of parsed words pointer
 2FD  0112C                                LOAD s1, 2C[CLI_WORD_1]                          ;load start of parsed words pointer
 2FE                cmd_parse_tokens_zero: 
 2FE  01000                                LOAD s0, 00
 2FF  2E010                                STORE s0, (s1)                                   ;zero word data
 300  11101                                ADD s1, 01
 301  1C120                                COMPARE s1, s2                                   ;check that we are still below the end ptr
 302  3A2FE                                JUMP C, 2FE[cmd_parse_tokens_zero]
 303                                       ;; begin parsing
 303  01400                                LOAD s4, 00                                      ; store the offset to the current word
 304          cmd_parse_tokens_next_token: 
 304  0B023                                FETCH s0, 23[CLI_COUNT]                          ; store the number of words to parse
 305  1C400                                COMPARE s4, s0
 306  3E325                                JUMP NC, 325[cmd_parse_tokens_done]              ; jump to done when we are through the counts
 307                                       ;; find the start of the buffer
 307  01024                                LOAD s0, 24[CLI_WORD_1_POS]                      ; Get the position of the first pos
 308  10040                                ADD s0, s4                                       ; Move to the current pos
 309  0A500                                FETCH s5, (s0)                                   ; get the start of the word buffer
 30A                                       ;; find the end of the buffer
 30A  01128                                LOAD s1, 28[CLI_WORD_1_SIZE]
 30B  10140                                ADD s1, s4                                       ; find size of this word in nibbles
 30C  0A610                                FETCH s6, (s1)
 30D  10650                                ADD s6, s5                                       ; move size past the start
 30E                                       ;; find the place we are storing the binary data
 30E  00740                                LOAD s7, s4                                      ; load the word number (-1)
 30F  14706                                SL0 s7
 310  14706                                SL0 s7                                           ; multiply by 4 since thats how many bytes we allocate
 311  1172C                                ADD s7, 2C[CLI_WORD_1]                           ; move to the byte after this word
 312                                       ;; update word index for next time
 312  11401                                ADD s4, 01
 313               cmd_parse_tokens_parse: 
 313  19602                                SUB s6, 02                                       ; move back a byte of data in the buffer
 314  1C650                                COMPARE s6, s5                                   ; check that we have a full byte to parse
 315  3A31E                                JUMP C, 31E[cmd_parse_nibble]
 316                                       ;; parse a byte
 316  0A260                                FETCH s2, (s6)
 317  11601                                ADD s6, 01
 318  0A160                                FETCH s1, (s6)
 319  19601                                SUB s6, 01
 31A  2001C                                CALL 01C[util_hex_to_byte]                       ; convert two hex digits to hex
 31B  2E070                                STORE s0, (s7)                                   ; store this byte
 31C  11701                                ADD s7, 01                                       ; move forward in data
 31D  22313                                JUMP 313[cmd_parse_tokens_parse]
 31E                     cmd_parse_nibble: 
 31E  11601                                ADD s6, 01
 31F  1C650                                COMPARE s6, s5
 320  36304                                JUMP NZ, 304[cmd_parse_tokens_next_token]        ; there isn't even a nibble to parse
 321                                       ;; parse the nibble
 321  0A060                                FETCH s0, (s6)
 322  2002F                                CALL 02F[util_char_to_nibble]
 323  2E070                                STORE s0, (s7)
 324  22304                                JUMP 304[cmd_parse_tokens_next_token]
 325                cmd_parse_tokens_done: 
 325  25000                                RETURN 
 326                                       ;;; ============================================================================
 326                                       ;;; Main UART UI LOOP
 326                                       ;; uses s0-s1
 326                                       ;;; ============================================================================
 326                             cli_loop: 
 326  20006                                CALL 006[uart_input_wait]                        ; wait for input
 327  09001                                INPUT s0, 01[UART_INPUT]                         ; read new char from UART
 328  0B120                                FETCH s1, 20[CLI_BUFFER]                         ; get current write pointer
 329  11100                                ADD s1, 00[CLI_BUFFER_START]                     ; add CLI_BUFFER_START
 32A  2E010                                STORE s0, (s1)                                   ; store input in CLI_BUFFER
 32B  0B120                                FETCH s1, 20[CLI_BUFFER]                         ; update CLI_BUFFER
 32C  11101                                ADD s1, 01
 32D  2F120                                STORE s1, 20[CLI_BUFFER]                         ;
 32E  1D120                                COMPARE s1, 20[CLI_BUFFER]                       ; check for CLI BUFFER overflow
 32F  3E33D                                JUMP NC, 33D[cli_overflow]
 330  20345                                CALL 345[cli_process]                            ; process the new char
 331                                       ; return C=1 if a command
 331  3827D                                CALL C, 27D[cmd_find]                            ; process a new command
 332  22326                                JUMP 326[cli_loop]
 333                                       ;;; ============================================================================
 333                                       ;;; Error for UI overflow
 333                                       ;; uses s0-s1
 333                                       ;;; ============================================================================
 333                                       STRING overflow$, "Overflow!"
 333                         str_overflow: 
 333  2114F                                LOAD&RETURN s1, 4F[overflow$:"O"]
 334  21176                                LOAD&RETURN s1, 76[overflow$:"v"]
 335  21165                                LOAD&RETURN s1, 65[overflow$:"e"]
 336  21172                                LOAD&RETURN s1, 72[overflow$:"r"]
 337  21166                                LOAD&RETURN s1, 66[overflow$:"f"]
 338  2116C                                LOAD&RETURN s1, 6C[overflow$:"l"]
 339  2116F                                LOAD&RETURN s1, 6F[overflow$:"o"]
 33A  21177                                LOAD&RETURN s1, 77[overflow$:"w"]
 33B  21121                                LOAD&RETURN s1, 21[overflow$:"!"]
 33C  21100                                LOAD&RETURN s1, 00
 33D                         cli_overflow: 
 33D  20059                                CALL 059[util_print_EOL]
 33E  01B03                                LOAD sB, 03[str_overflow'upper]
 33F  01A33                                LOAD sA, 33[str_overflow'lower]
 340  20064                                CALL 064[util_print_string]
 341  20059                                CALL 059[util_print_EOL]
 342  2009E                                CALL 09E[soft_reset]
 343  20060                                CALL 060[util_print_prompt]
 344  22326                                JUMP 326[cli_loop]
 345                                       ;;; ============================================================================
 345                                       ;;; parse the current text inputted by the user
 345                                       ;; check for special characters
 345                                       ;; echo back to use if needed
 345                                       ;; set C = 1 if the user pressed enter
 345                                       ;; uses s0-s1
 345                                       ;;; ============================================================================
 345                          cli_process: 
 345                                       ;; check last char for something special
 345  0B020                                FETCH s0, 20[CLI_BUFFER]
 346  19001                                SUB s0, 01
 347  0A100                                FETCH s1, (s0)                                   ; load the last ASCII into s0
 348  1D10D                                COMPARE s1, 0D                                   ; check for CR
 349  3235B                                JUMP Z, 35B[cli_process_cmd]
 34A  1D10A                                COMPARE s1, 0A                                   ; check for LF
 34B  3235B                                JUMP Z, 35B[cli_process_cmd]
 34C  1D108                                COMPARE s1, 08                                   ; check for backspace
 34D  32362                                JUMP Z, 362[cli_process_bs]
 34E  1D120                                COMPARE s1, 20                                   ; check for other special char
 34F  3E356                                JUMP NC, 356[cli_process_text]                   ; jump for user text
 350                                       ;; remove special char
 350  0B020                                FETCH s0, 20[CLI_BUFFER]
 351  19001                                SUB s0, 01
 352  2F020                                STORE s0, 20[CLI_BUFFER]
 353  01000                                LOAD s0, 00
 354  1400C                                RR s0                                            ; set C to zero (no command)
 355  25000                                RETURN 
 356                     cli_process_text: 
 356  20002                                CALL 002[uart_output_wait]                       ; nothing special
 357  2D101                                OUTPUT s1, 01[UART_OUTPUT]                       ; echo char back to user
 358  01000                                LOAD s0, 00
 359  1400C                                RR s0                                            ; set C to zero (no command)
 35A  25000                                RETURN 
 35B                      cli_process_cmd: 
 35B                                       ;; respond with EOL
 35B  20059                                CALL 059[util_print_EOL]
 35C                                       ;; remove the CR/LF character from memory
 35C  0B020                                FETCH s0, 20[CLI_BUFFER]
 35D  19001                                SUB s0, 01                                       ; remove CR/LF from memory
 35E  2F020                                STORE s0, 20[CLI_BUFFER]
 35F                                       ;; return with C = 1
 35F  01001                                LOAD s0, 01
 360  1400C                                RR s0                                            ; set C to one
 361  25000                                RETURN 
 362                       cli_process_bs: 
 362  0B020                                FETCH s0, 20[CLI_BUFFER]                         ; check if there is anything to bs into
 363  19002                                SUB s0, 02                                       ; because we've already moved 1 ahead in CLI_BUFFER
 364  3A371                                JUMP C, 371[cli_process_bs_done]
 365                                       ;; update display
 365  20002                                CALL 002[uart_output_wait]
 366  01108                                LOAD s1, 08                                      ; backspace
 367  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 368  20002                                CALL 002[uart_output_wait]
 369  01120                                LOAD s1, 20[" "]                                 ; blank (clears bad char)
 36A  2D101                                OUTPUT s1, 01[UART_OUTPUT]
 36B  20002                                CALL 002[uart_output_wait]
 36C  01108                                LOAD s1, 08
 36D  2D101                                OUTPUT s1, 01[UART_OUTPUT]                       ; correctly sets next input char pos on screen
 36E                                       ;; we need to remove a total of two chars from buffer (bad + bs)
 36E                                       ;; remove one of them and leave one
 36E  0B020                                FETCH s0, 20[CLI_BUFFER]
 36F  19001                                SUB s0, 01
 370  2F020                                STORE s0, 20[CLI_BUFFER]
 371                  cli_process_bs_done: 
 371                                       ;; We need to remove one character from buffer
 371  0B020                                FETCH s0, 20[CLI_BUFFER]
 372  19001                                SUB s0, 01
 373  2F020                                STORE s0, 20[CLI_BUFFER]
 374                                       ;; set C to zero since there was no command
 374  01000                                LOAD s0, 00
 375  1400C                                RR s0                                            ; set C to zero because there is no new command
 376  25000                                RETURN 



List of PSM files that have been assembled

Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cli.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\uart.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\utils.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\spi.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmd_names.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_C.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_D.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_F.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_G.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_H.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_M.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_P.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_R.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_S.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_T.psm
Z:\home\dean\public_html\Xilinx\testpulses\src\pico\cmds_V.psm



List of defined constants

 CONSTANT name               Value        Source PSM File

 timestamp_hours             11'd         
 timestamp_minutes           43'd         
 timestamp_seconds           03'd         
 datestamp_year              14'd         
 datestamp_month             2'd          
 datestamp_day               19'd         
 NUL                         00           
 BEL                         07           
 BS                          08           
 HT                          09           
 LF                          0A           
 VT                          0B           
 CR                          0D           
 ESC                         1B           
 DEL                         7F           
 DCS                         90           
 ST                          9C           
 CLI_BUFFER_START            00           cli.psm
 CLI_BUFFER                  20           cli.psm
 CLI_COUNT                   23           cli.psm
 CLI_WORD_1_POS              24           cli.psm
 CLI_WORD_2_POS              25           cli.psm
 CLI_WORD_3_POS              26           cli.psm
 CLI_WORD_4_POS              27           cli.psm
 CLI_WORD_1_SIZE             28           cli.psm
 CLI_WORD_2_SIZE             29           cli.psm
 CLI_WORD_3_SIZE             2A           cli.psm
 CLI_WORD_4_SIZE             2B           cli.psm
 CLI_WORD_1                  2C           cli.psm
 CLI_WORD_2                  30           cli.psm
 CLI_WORD_3                  34           cli.psm
 CLI_WORD_4                  38           cli.psm
 MEM_USER_1                  40           cli.psm
 MEM_USER_2                  80           cli.psm
 MEM_USER_3                  C0           cli.psm
 MEM_SIZE                    FF           cli.psm
 UI_VERSION                  01           cli.psm
 FIFO_data                   03           cli.psm
 FIFO_flags                  04           cli.psm
 UART_TX_RESET_PORT          00           cli.psm
 INITPORT                    00001000'b   cli.psm
 ONCEPORT                    00001001'b   cli.psm
 LED_PORT                    00000010'b   cli.psm
 SPI_PORT                    00000011'b   cli.psm
 PERIOD_PORT0                01000000'b   cli.psm
 PERIOD_PORT1                01000001'b   cli.psm
 PERIOD_PORT2                01000010'b   cli.psm
 PULSE_PERIOD_PORT0          01000100'b   cli.psm
 PULSE_PERIOD_PORT1          01000101'b   cli.psm
 PULSE_PERIOD_PORT2          01000110'b   cli.psm
 CTRL_port                   00100000'b   cli.psm
 C5_data                     11100000'b   cli.psm
 RESET_fifo_port             11100010'b   cli.psm
 spi_clk                     00000001'b   cli.psm
 spi_cs                      00000010'b   cli.psm
 spi_mosi                    10000000'b   cli.psm
 UART_STATUS                 00           uart.psm
 UART_INPUT                  01           uart.psm
 UART_OUTPUT                 01           uart.psm
 UART_STATUS_Tx_data_present 00000001'b   uart.psm
 UART_STATUS_Tx_half_full    00000010'b   uart.psm
 UART_STATUS_Tx_full         00000100'b   uart.psm
 UART_STATUS_Rx_data_present 00001000'b   uart.psm
 UART_STATUS_Rx_half_full    00010000'b   uart.psm
 UART_STATUS_Rx_full         00100000'b   uart.psm



No TABLEs defined



List of text strings

 STRING name       String             Source PSM File

 KCPSM6_version$   "v2.46"            
 datestamp$        "19 Feb 2014"      
 timestamp$        "11:43:03"         
 startup$          "CLI V:"           cli.psm
 BUFFER$           "Buffer: "         cmds_S.psm
 WORD_COUNT$       "Word count: "     cmds_S.psm
 WORD_SIZE$        "Word sizes:    "  cmds_S.psm
 WORD$             "Word "            cmds_S.psm
 ver$              "Version: "        cmds_V.psm
 multiarg$         "multiarg"         cmd_names.psm
 memdump$          "memdump"          cmd_names.psm
 reset$            "reset"            cmd_names.psm
 version$          "version"          cmd_names.psm
 sys$              "sys"              cmd_names.psm
 help$             "help"             cmd_names.psm
 dac$              "d"                cmd_names.psm
 channel$          "c"                cmd_names.psm
 fire$             "s"                cmd_names.psm
 rapid_on$         "n"                cmd_names.psm
 rapid_off$        "m"                cmd_names.psm
 cont_start$       "a"                cmd_names.psm
 cont_stop$        "z"                cmd_names.psm
 period$           "p"                cmd_names.psm
 pulse_period$     "t"                cmd_names.psm
 GEN_C5$           "CC"               cmd_names.psm
 GEN_D5$           "CD"               cmd_names.psm
 FIFO_flags$       "F"                cmd_names.psm
 FIFO_read$        "D"                cmd_names.psm
 FIFO_reset$       "R"                cmd_names.psm
 TDC_loopback$     "M"                cmd_names.psm
 BadCommand$       "Bad command"      cmds.psm
 Error$            "Error: "          cmds.psm
 overflow$         "Overflow!"        cli.psm



List of line labels

   Label                          Addr  Source PSM File

 * start                          000   cli.psm
   uart_output_wait               002   uart.psm
   uart_input_wait                006   uart.psm
 * uart_input_data                00A   uart.psm
 * uart_output_data               00D   uart.psm
 * uart_input_full                010   uart.psm
 * uart_output_full               013   uart.psm
 * uart_input_half_full           016   uart.psm
 * uart_output_half_full          019   uart.psm
   util_hex_to_byte               01C   utils.psm
   util_hex_to_byte_error         02C   utils.psm
   util_char_to_nibble            02F   utils.psm
   util_char_to_nibble_error      03D   utils.psm
   util_char_to_nibble_finish     040   utils.psm
   util_byte_to_hex               041   utils.psm
   util_byte_to_hex_next          04B   utils.psm
   util_byte_to_hex_end           052   utils.psm
   util_print_hex_byte            053   utils.psm
   util_print_EOL                 059   utils.psm
   util_print_prompt              060   utils.psm
   util_print_string              064   utils.psm
   util_print_string_end          06C   utils.psm
   send_spi                       06D   spi.psm
   next_bit                       06E   spi.psm
   clock_pulse                    07B   spi.psm
   sdelay                         083   spi.psm
   DLOOP                          085   spi.psm
   str_startup                    088   cli.psm
   hard_reset                     08F   cli.psm
   soft_reset                     09E   cli.psm
   CMD_channel                    0A2   cmds_C.psm
   CMD_cont_start                 0B3   cmds_C.psm
   CMD_cont_stop                  0B6   cmds_C.psm
   CMD_dac                        0B9   cmds_D.psm
   CMD_fire                       0BF   cmds_F.psm
   CMD_FIFO_flags                 0C4   cmds_F.psm
   CMD_FIFO_read                  0C8   cmds_F.psm
 * FIFO_read_all                  0CF   cmds_F.psm
   FIFO_read_len                  0D2   cmds_F.psm
   do_D_init_read                 0D6   cmds_F.psm
   do_D_read                      0D9   cmds_F.psm
   do_D_empty                     0E6   cmds_F.psm
   CMD_FIFO_reset                 0EA   cmds_F.psm
   CMD_GEN_C5                     0EE   cmds_G.psm
   CMD_GEN_D5                     0F2   cmds_G.psm
   CMD_help                       0F5   cmds_H.psm
   CMD_help_loop                  0F7   cmds_H.psm
   CMD_help_eol                   101   cmds_H.psm
   CMD_help_end                   105   cmds_H.psm
   CMD_Mem_dump                   107   cmds_M.psm
   CMD_Mem_dump_loop              108   cmds_M.psm
   CMD_Mem_dump_line_loop         114   cmds_M.psm
   CMD_Mem_dump_end               123   cmds_M.psm
   CMD_multiarg                   125   cmds_M.psm
   CMD_multiarg_end               12F   cmds_M.psm
   CMD_period                     130   cmds_P.psm
   CMD_pulse_period               13D   cmds_P.psm
   CMD_reset                      14A   cmds_R.psm
   CMD_rapid_on                   14C   cmds_R.psm
   CMD_rapid_off                  14F   cmds_R.psm
   str_BUFFER                     152   cmds_S.psm
   str_WORD_COUNT                 15B   cmds_S.psm
   str_WORD_SIZE                  168   cmds_S.psm
   str_WORD                       178   cmds_S.psm
   CMD_sys                        17E   cmds_S.psm
   CMD_sys_buffer                 183   cmds_S.psm
   CMD_sys_buffer_size            18A   cmds_S.psm
 * CMD_sys_word_count             19A   cmds_S.psm
   CMD_sys_word_pos               1A6   cmds_S.psm
   CMD_sys_word_size              1B8   cmds_S.psm
   CMD_sys_word_size_loop         1BE   cmds_S.psm
   CMD_sys_word                   1CD   cmds_S.psm
   CMD_sys_word_loop              1D0   cmds_S.psm
   CMD_sys_word_loop_print_loop   1E6   cmds_S.psm
   CMD_sys_word_end               1F0   cmds_S.psm
   CMD_TDC_loopback               1F2   cmds_T.psm
   str_ver                        1F5   cmds_V.psm
   CMD_version                    1FF   cmds_V.psm
   cmds                           20A   cmd_names.psm
   cmd_find                       27D   cmds.psm
   cmd_find_loop                  280   cmds.psm
   cmd_find_next                  28F   cmds.psm
   cmd_find_next_reset            297   cmds.psm
   cmd_find_call                  29B   cmds.psm
   cmd_find_failed                2A8   cmds.psm
   cmd_tokenize                   2AC   cmds.psm
   cmd_tokenize_loop              2AE   cmds.psm
   cmd_tokenize_size              2C4   cmds.psm
   cmd_tokenize_size_end          2CB   cmds.psm
   cmd_tokenize_end               2D6   cmds.psm
   str_BadCommand                 2D7   cmds.psm
   cmd_invalid                    2E3   cmds.psm
   str_Error                      2E8   cmds.psm
 * cmd_error                      2F0   cmds.psm
   cmd_parse_tokens               2FB   cmds.psm
   cmd_parse_tokens_zero          2FE   cmds.psm
   cmd_parse_tokens_next_token    304   cmds.psm
   cmd_parse_tokens_parse         313   cmds.psm
   cmd_parse_nibble               31E   cmds.psm
   cmd_parse_tokens_done          325   cmds.psm
   cli_loop                       326   cli.psm
   str_overflow                   333   cli.psm
   cli_overflow                   33D   cli.psm
   cli_process                    345   cli.psm
   cli_process_text               356   cli.psm
   cli_process_cmd                35B   cli.psm
   cli_process_bs                 362   cli.psm
   cli_process_bs_done            371   cli.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD            107
 STAR              -

 AND               6
 OR                4
 XOR               -

 ADD              58
 ADDCY             8
 SUB              21
 SUBCY             1

 TEST              8
 TESTCY            -
 COMPARE          36
 COMPARECY         -

 SL0              11
 SL1               -
 SLX               -
 SLA               1
 RL                -
 SR0               7
 SR1               -
 SRX               -
 SRA               -
 RR                4

 REGBANK           -

 INPUT            12
 OUTPUT           69
 OUTPUTK           2

 STORE            56
 FETCH            56

 DISABLE           -
 ENABLE            -
 RETURNI           -

 JUMP             73
 JUMP@             -
 CALL            121
 CALL@             7
 RETURN           54
 LOAD&RETURN     206

 HWBUILD           -



End of KCPSM6 log file.
